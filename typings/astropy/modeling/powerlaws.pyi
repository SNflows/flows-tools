"""
This type stub file was generated by pyright.
"""

from .core import Fittable1DModel

"""
Power law model variants
"""
__all__ = ['PowerLaw1D', 'BrokenPowerLaw1D', 'SmoothlyBrokenPowerLaw1D', 'ExponentialCutoffPowerLaw1D', 'LogParabola1D', 'Schechter1D']
class PowerLaw1D(Fittable1DModel):
    """
    One dimensional power law model.

    Parameters
    ----------
    amplitude : float
        Model amplitude at the reference point
    x_0 : float
        Reference point
    alpha : float
        Power law index

    See Also
    --------
    BrokenPowerLaw1D, ExponentialCutoffPowerLaw1D, LogParabola1D

    Notes
    -----
    Model formula (with :math:`A` for ``amplitude`` and :math:`\\alpha` for ``alpha``):

        .. math:: f(x) = A (x / x_0) ^ {-\\alpha}

    """
    amplitude = ...
    x_0 = ...
    alpha = ...
    @staticmethod
    def evaluate(x, amplitude, x_0, alpha):
        """One dimensional power law model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, x_0, alpha): # -> list[Unknown]:
        """One dimensional power law derivative with respect to parameters"""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class BrokenPowerLaw1D(Fittable1DModel):
    """
    One dimensional power law model with a break.

    Parameters
    ----------
    amplitude : float
        Model amplitude at the break point.
    x_break : float
        Break point.
    alpha_1 : float
        Power law index for x < x_break.
    alpha_2 : float
        Power law index for x > x_break.

    See Also
    --------
    PowerLaw1D, ExponentialCutoffPowerLaw1D, LogParabola1D

    Notes
    -----
    Model formula (with :math:`A` for ``amplitude`` and :math:`\\alpha_1`
    for ``alpha_1`` and :math:`\\alpha_2` for ``alpha_2``):

        .. math::

            f(x) = \\left \\{
                     \\begin{array}{ll}
                       A (x / x_{break}) ^ {-\\alpha_1} & : x < x_{break} \\\\
                       A (x / x_{break}) ^ {-\\alpha_2} & :  x > x_{break} \\\\
                     \\end{array}
                   \\right.
    """
    amplitude = ...
    x_break = ...
    alpha_1 = ...
    alpha_2 = ...
    @staticmethod
    def evaluate(x, amplitude, x_break, alpha_1, alpha_2):
        """One dimensional broken power law model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, x_break, alpha_1, alpha_2): # -> list[Unknown | NDArray[Any]]:
        """One dimensional broken power law derivative with respect to parameters"""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class SmoothlyBrokenPowerLaw1D(Fittable1DModel):
    """One dimensional smoothly broken power law model.

    Parameters
    ----------
    amplitude : float
        Model amplitude at the break point.
    x_break : float
        Break point.
    alpha_1 : float
        Power law index for ``x << x_break``.
    alpha_2 : float
        Power law index for ``x >> x_break``.
    delta : float
        Smoothness parameter.

    See Also
    --------
    BrokenPowerLaw1D

    Notes
    -----
    Model formula (with :math:`A` for ``amplitude``, :math:`x_b` for
    ``x_break``, :math:`\\alpha_1` for ``alpha_1``,
    :math:`\\alpha_2` for ``alpha_2`` and :math:`\\Delta` for
    ``delta``):

        .. math::

            f(x) = A \\left( \\frac{x}{x_b} \\right) ^ {-\\alpha_1}
                   \\left\\{
                      \\frac{1}{2}
                      \\left[
                        1 + \\left( \\frac{x}{x_b}\\right)^{1 / \\Delta}
                      \\right]
                   \\right\\}^{(\\alpha_1 - \\alpha_2) \\Delta}


    The change of slope occurs between the values :math:`x_1`
    and :math:`x_2` such that:

        .. math::
            \\log_{10} \\frac{x_2}{x_b} = \\log_{10} \\frac{x_b}{x_1}
            \\sim \\Delta


    At values :math:`x \\lesssim x_1` and :math:`x \\gtrsim x_2` the
    model is approximately a simple power law with index
    :math:`\\alpha_1` and :math:`\\alpha_2` respectively.  The two
    power laws are smoothly joined at values :math:`x_1 < x < x_2`,
    hence the :math:`\\Delta` parameter sets the "smoothness" of the
    slope change.

    The ``delta`` parameter is bounded to values greater than 1e-3
    (corresponding to :math:`x_2 / x_1 \\gtrsim 1.002`) to avoid
    overflow errors.

    The ``amplitude`` parameter is bounded to positive values since
    this model is typically used to represent positive quantities.


    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt
        from astropy.modeling import models

        x = np.logspace(0.7, 2.3, 500)
        f = models.SmoothlyBrokenPowerLaw1D(amplitude=1, x_break=20,
                                            alpha_1=-2, alpha_2=2)

        plt.figure()
        plt.title("amplitude=1, x_break=20, alpha_1=-2, alpha_2=2")

        f.delta = 0.5
        plt.loglog(x, f(x), '--', label='delta=0.5')

        f.delta = 0.3
        plt.loglog(x, f(x), '-.', label='delta=0.3')

        f.delta = 0.1
        plt.loglog(x, f(x), label='delta=0.1')

        plt.axis([x.min(), x.max(), 0.1, 1.1])
        plt.legend(loc='lower center')
        plt.grid(True)
        plt.show()

    """
    amplitude = ...
    x_break = ...
    alpha_1 = ...
    alpha_2 = ...
    delta = ...
    @amplitude.validator
    def amplitude(self, value): # -> None:
        ...
    
    @delta.validator
    def delta(self, value): # -> None:
        ...
    
    @staticmethod
    def evaluate(x, amplitude, x_break, alpha_1, alpha_2, delta): # -> Quantity | NDArray[Unknown]:
        """One dimensional smoothly broken power law model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, x_break, alpha_1, alpha_2, delta): # -> list[Unknown]:
        """One dimensional smoothly broken power law derivative with respect
           to parameters"""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class ExponentialCutoffPowerLaw1D(Fittable1DModel):
    """
    One dimensional power law model with an exponential cutoff.

    Parameters
    ----------
    amplitude : float
        Model amplitude
    x_0 : float
        Reference point
    alpha : float
        Power law index
    x_cutoff : float
        Cutoff point

    See Also
    --------
    PowerLaw1D, BrokenPowerLaw1D, LogParabola1D

    Notes
    -----
    Model formula (with :math:`A` for ``amplitude`` and :math:`\\alpha` for ``alpha``):

        .. math:: f(x) = A (x / x_0) ^ {-\\alpha} \\exp (-x / x_{cutoff})

    """
    amplitude = ...
    x_0 = ...
    alpha = ...
    x_cutoff = ...
    @staticmethod
    def evaluate(x, amplitude, x_0, alpha, x_cutoff):
        """One dimensional exponential cutoff power law model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, x_0, alpha, x_cutoff): # -> list[Unknown]:
        """One dimensional exponential cutoff power law derivative with respect to parameters"""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class LogParabola1D(Fittable1DModel):
    """
    One dimensional log parabola model (sometimes called curved power law).

    Parameters
    ----------
    amplitude : float
        Model amplitude
    x_0 : float
        Reference point
    alpha : float
        Power law index
    beta : float
        Power law curvature

    See Also
    --------
    PowerLaw1D, BrokenPowerLaw1D, ExponentialCutoffPowerLaw1D

    Notes
    -----
    Model formula (with :math:`A` for ``amplitude`` and
    :math:`\\alpha` for ``alpha`` and :math:`\\beta` for ``beta``):

        .. math:: f(x) = A \\left(
                \\frac{x}{x_{0}}\\right)^{- \\alpha - \\beta \\log{\\left (\\frac{x}{x_{0}}
            \\right )}}

    """
    amplitude = ...
    x_0 = ...
    alpha = ...
    beta = ...
    @staticmethod
    def evaluate(x, amplitude, x_0, alpha, beta):
        """One dimensional log parabola model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, x_0, alpha, beta): # -> list[Unknown]:
        """One dimensional log parabola derivative with respect to parameters"""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Schechter1D(Fittable1DModel):
    r"""
    Schechter luminosity function (`Schechter 1976
    <https://ui.adsabs.harvard.edu/abs/1976ApJ...203..297S/abstract>`_),
    parameterized in terms of magnitudes.

    Parameters
    ----------
    phi_star : float
        The normalization factor in units of number density.

    m_star : float
        The characteristic magnitude where the power-law form of the
        function cuts off. Must not have units.

    alpha : float
        The power law index, also known as the faint-end slope. Must not
        have units.

    See Also
    --------
    PowerLaw1D, ExponentialCutoffPowerLaw1D, BrokenPowerLaw1D

    Notes
    -----
    Model formula (with :math:`\phi^{*}` for ``phi_star``, :math:`M^{*}`
    for ``m_star``, and :math:`\alpha` for ``alpha``):

    .. math::

        n(M) \ dM = (0.4 \ln 10) \ \phi^{*} \
            [{10^{0.4 (M^{*} - M)}}]^{\alpha + 1} \
            \exp{[-10^{0.4 (M^{*} - M)}]} \ dM

    ``phi_star`` is the normalization factor in units of number density.
    ``m_star`` is the characteristic magnitude where the power-law form
    of the function cuts off into the exponential form. ``alpha`` is
    the power-law index, defining the faint-end slope of the luminosity
    function.

    Examples
    --------
    .. plot::
        :include-source:

        from astropy.modeling.models import Schechter1D
        import astropy.units as u
        import matplotlib.pyplot as plt
        import numpy as np

        phi_star = 4.3e-4 * (u.Mpc ** -3)
        m_star = -20.26
        alpha = -1.98
        model = Schechter1D(phi_star, m_star, alpha)
        mag = np.linspace(-25, -17)

        fig, ax = plt.subplots()
        ax.plot(mag, model(mag))
        ax.set_yscale('log')
        ax.set_xlim(-22.6, -17)
        ax.set_ylim(1.e-7, 1.e-2)
        ax.set_xlabel('$M_{UV}$')
        ax.set_ylabel('$\phi$ [mag$^{-1}$ Mpc$^{-3}]$')

    References
    ----------
    .. [1] Schechter 1976; ApJ 203, 297
           (https://ui.adsabs.harvard.edu/abs/1976ApJ...203..297S/abstract)

    .. [2] `Luminosity function <https://en.wikipedia.org/wiki/Luminosity_function_(astronomy)>`_
    """
    phi_star = ...
    m_star = ...
    alpha = ...
    def evaluate(self, mag, phi_star, m_star, alpha):
        """Schechter luminosity function model function."""
        ...
    
    def fit_deriv(self, mag, phi_star, m_star, alpha): # -> list[Unknown]:
        """
        Schechter luminosity function derivative with respect to
        parameters.
        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


