"""
This type stub file was generated by pyright.
"""

import numpy as np
from .core import Fittable1DModel, Fittable2DModel

"""Mathematical models."""
__all__ = ['AiryDisk2D', 'Moffat1D', 'Moffat2D', 'Box1D', 'Box2D', 'Const1D', 'Const2D', 'Ellipse2D', 'Disk2D', 'Gaussian1D', 'Gaussian2D', 'Linear1D', 'Lorentz1D', 'RickerWavelet1D', 'RickerWavelet2D', 'RedshiftScaleFactor', 'Multiply', 'Planar2D', 'Scale', 'Sersic1D', 'Sersic2D', 'Shift', 'Sine1D', 'Cosine1D', 'Tangent1D', 'ArcSine1D', 'ArcCosine1D', 'ArcTangent1D', 'Trapezoid1D', 'TrapezoidDisk2D', 'Ring2D', 'Voigt1D', 'KingProjectedAnalytic1D', 'Exponential1D', 'Logarithmic1D']
TWOPI = ...
FLOAT_EPSILON = ...
GAUSSIAN_SIGMA_TO_FWHM = 2 * np.sqrt(2 * np.log(2))
class Gaussian1D(Fittable1DModel):
    """
    One dimensional Gaussian model.

    Parameters
    ----------
    amplitude : float or `~astropy.units.Quantity`.
        Amplitude (peak value) of the Gaussian - for a normalized profile
        (integrating to 1), set amplitude = 1 / (stddev * np.sqrt(2 * np.pi))
    mean : float or `~astropy.units.Quantity`.
        Mean of the Gaussian.
    stddev : float or `~astropy.units.Quantity`.
        Standard deviation of the Gaussian with FWHM = 2 * stddev * np.sqrt(2 * np.log(2)).

    Notes
    -----
    Either all or none of input ``x``, ``mean`` and ``stddev`` must be provided
    consistently with compatible units or as unitless numbers.

    Model formula:

        .. math:: f(x) = A e^{- \\frac{\\left(x - x_{0}\\right)^{2}}{2 \\sigma^{2}}}

    Examples
    --------
    >>> from astropy.modeling import models
    >>> def tie_center(model):
    ...         mean = 50 * model.stddev
    ...         return mean
    >>> tied_parameters = {'mean': tie_center}

    Specify that 'mean' is a tied parameter in one of two ways:

    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,
    ...                             tied=tied_parameters)

    or

    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)
    >>> g1.mean.tied
    False
    >>> g1.mean.tied = tie_center
    >>> g1.mean.tied
    <function tie_center at 0x...>

    Fixed parameters:

    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3,
    ...                        fixed={'stddev': True})
    >>> g1.stddev.fixed
    True

    or

    >>> g1 = models.Gaussian1D(amplitude=10, mean=5, stddev=.3)
    >>> g1.stddev.fixed
    False
    >>> g1.stddev.fixed = True
    >>> g1.stddev.fixed
    True

    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import Gaussian1D

        plt.figure()
        s1 = Gaussian1D()
        r = np.arange(-5, 5, .01)

        for factor in range(1, 4):
            s1.amplitude = factor
            plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)

        plt.axis([-5, 5, -1, 4])
        plt.show()

    See Also
    --------
    Gaussian2D, Box1D, Moffat1D, Lorentz1D
    """
    amplitude = ...
    mean = ...
    stddev = ...
    def bounding_box(self, factor=...): # -> tuple[Unknown, Unknown]:
        """
        Tuple defining the default ``bounding_box`` limits,
        ``(x_low, x_high)``

        Parameters
        ----------
        factor : float
            The multiple of `stddev` used to define the limits.
            The default is 5.5, corresponding to a relative error < 1e-7.

        Examples
        --------
        >>> from astropy.modeling.models import Gaussian1D
        >>> model = Gaussian1D(mean=0, stddev=2)
        >>> model.bounding_box
        ModelBoundingBox(
            intervals={
                x: Interval(lower=-11.0, upper=11.0)
            }
            model=Gaussian1D(inputs=('x',))
            order='C'
        )

        This range can be set directly (see: `Model.bounding_box
        <astropy.modeling.Model.bounding_box>`) or by using a different factor,
        like:

        >>> model.bounding_box = model.bounding_box(factor=2)
        >>> model.bounding_box
        ModelBoundingBox(
            intervals={
                x: Interval(lower=-4.0, upper=4.0)
            }
            model=Gaussian1D(inputs=('x',))
            order='C'
        )
        """
        ...
    
    @property
    def fwhm(self): # -> Any:
        """Gaussian full width at half maximum."""
        ...
    
    @staticmethod
    def evaluate(x, amplitude, mean, stddev):
        """
        Gaussian1D model function.
        """
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, mean, stddev): # -> list[Any | Unknown]:
        """
        Gaussian1D model function derivatives.
        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Gaussian2D(Fittable2DModel):
    r"""
    Two dimensional Gaussian model.

    Parameters
    ----------
    amplitude : float or `~astropy.units.Quantity`.
        Amplitude (peak value) of the Gaussian.
    x_mean : float or `~astropy.units.Quantity`.
        Mean of the Gaussian in x.
    y_mean : float or `~astropy.units.Quantity`.
        Mean of the Gaussian in y.
    x_stddev : float or `~astropy.units.Quantity` or None.
        Standard deviation of the Gaussian in x before rotating by theta. Must
        be None if a covariance matrix (``cov_matrix``) is provided. If no
        ``cov_matrix`` is given, ``None`` means the default value (1).
    y_stddev : float or `~astropy.units.Quantity` or None.
        Standard deviation of the Gaussian in y before rotating by theta. Must
        be None if a covariance matrix (``cov_matrix``) is provided. If no
        ``cov_matrix`` is given, ``None`` means the default value (1).
    theta : float or `~astropy.units.Quantity`, optional.
        The rotation angle as an angular quantity
        (`~astropy.units.Quantity` or `~astropy.coordinates.Angle`)
        or a value in radians (as a float). The rotation angle
        increases counterclockwise. Must be `None` if a covariance matrix
        (``cov_matrix``) is provided. If no ``cov_matrix`` is given,
        `None` means the default value (0).
    cov_matrix : ndarray, optional
        A 2x2 covariance matrix. If specified, overrides the ``x_stddev``,
        ``y_stddev``, and ``theta`` defaults.

    Notes
    -----
    Either all or none of input ``x, y``, ``[x,y]_mean`` and ``[x,y]_stddev``
    must be provided consistently with compatible units or as unitless numbers.

    Model formula:

        .. math::

            f(x, y) = A e^{-a\left(x - x_{0}\right)^{2}  -b\left(x - x_{0}\right)
            \left(y - y_{0}\right)  -c\left(y - y_{0}\right)^{2}}

    Using the following definitions:

        .. math::
            a = \left(\frac{\cos^{2}{\left (\theta \right )}}{2 \sigma_{x}^{2}} +
            \frac{\sin^{2}{\left (\theta \right )}}{2 \sigma_{y}^{2}}\right)

            b = \left(\frac{\sin{\left (2 \theta \right )}}{2 \sigma_{x}^{2}} -
            \frac{\sin{\left (2 \theta \right )}}{2 \sigma_{y}^{2}}\right)

            c = \left(\frac{\sin^{2}{\left (\theta \right )}}{2 \sigma_{x}^{2}} +
            \frac{\cos^{2}{\left (\theta \right )}}{2 \sigma_{y}^{2}}\right)

    If using a ``cov_matrix``, the model is of the form:
        .. math::
            f(x, y) = A e^{-0.5 \left(
                    \vec{x} - \vec{x}_{0}\right)^{T} \Sigma^{-1} \left(\vec{x} - \vec{x}_{0}
                \right)}

    where :math:`\vec{x} = [x, y]`, :math:`\vec{x}_{0} = [x_{0}, y_{0}]`,
    and :math:`\Sigma` is the covariance matrix:

        .. math::
            \Sigma = \left(\begin{array}{ccc}
            \sigma_x^2               & \rho \sigma_x \sigma_y \\
            \rho \sigma_x \sigma_y   & \sigma_y^2
            \end{array}\right)

    :math:`\rho` is the correlation between ``x`` and ``y``, which should
    be between -1 and +1.  Positive correlation corresponds to a
    ``theta`` in the range 0 to 90 degrees.  Negative correlation
    corresponds to a ``theta`` in the range of 0 to -90 degrees.

    See [1]_ for more details about the 2D Gaussian function.

    See Also
    --------
    Gaussian1D, Box2D, Moffat2D

    References
    ----------
    .. [1] https://en.wikipedia.org/wiki/Gaussian_function
    """
    amplitude = ...
    x_mean = ...
    y_mean = ...
    x_stddev = ...
    y_stddev = ...
    theta = ...
    def __init__(self, amplitude=..., x_mean=..., y_mean=..., x_stddev=..., y_stddev=..., theta=..., cov_matrix=..., **kwargs) -> None:
        ...
    
    @property
    def x_fwhm(self): # -> Any:
        """Gaussian full width at half maximum in X."""
        ...
    
    @property
    def y_fwhm(self): # -> Any:
        """Gaussian full width at half maximum in Y."""
        ...
    
    def bounding_box(self, factor=...): # -> tuple[tuple[Any, Any], tuple[Any, Any]]:
        """
        Tuple defining the default ``bounding_box`` limits in each dimension,
        ``((y_low, y_high), (x_low, x_high))``

        The default offset from the mean is 5.5-sigma, corresponding
        to a relative error < 1e-7. The limits are adjusted for rotation.

        Parameters
        ----------
        factor : float, optional
            The multiple of `x_stddev` and `y_stddev` used to define the limits.
            The default is 5.5.

        Examples
        --------
        >>> from astropy.modeling.models import Gaussian2D
        >>> model = Gaussian2D(x_mean=0, y_mean=0, x_stddev=1, y_stddev=2)
        >>> model.bounding_box
        ModelBoundingBox(
            intervals={
                x: Interval(lower=-5.5, upper=5.5)
                y: Interval(lower=-11.0, upper=11.0)
            }
            model=Gaussian2D(inputs=('x', 'y'))
            order='C'
        )

        This range can be set directly (see: `Model.bounding_box
        <astropy.modeling.Model.bounding_box>`) or by using a different factor
        like:

        >>> model.bounding_box = model.bounding_box(factor=2)
        >>> model.bounding_box
        ModelBoundingBox(
            intervals={
                x: Interval(lower=-2.0, upper=2.0)
                y: Interval(lower=-4.0, upper=4.0)
            }
            model=Gaussian2D(inputs=('x', 'y'))
            order='C'
        )
        """
        ...
    
    @staticmethod
    def evaluate(x, y, amplitude, x_mean, y_mean, x_stddev, y_stddev, theta):
        """Two dimensional Gaussian function"""
        ...
    
    @staticmethod
    def fit_deriv(x, y, amplitude, x_mean, y_mean, x_stddev, y_stddev, theta): # -> list[Unknown]:
        """Two dimensional Gaussian function derivative with respect to parameters"""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Shift(Fittable1DModel):
    """
    Shift a coordinate.

    Parameters
    ----------
    offset : float
        Offset to add to a coordinate.
    """
    offset = ...
    linear = ...
    _has_inverse_bounding_box = ...
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    
    @property
    def inverse(self): # -> Self@Shift:
        """One dimensional inverse Shift model function"""
        ...
    
    @staticmethod
    def evaluate(x, offset):
        """One dimensional Shift model function"""
        ...
    
    @staticmethod
    def sum_of_implicit_terms(x):
        """Evaluate the implicit term (x) of one dimensional Shift model"""
        ...
    
    @staticmethod
    def fit_deriv(x, *params): # -> list[Unknown]:
        """One dimensional Shift model derivative with respect to parameter"""
        ...
    


class Scale(Fittable1DModel):
    """
    Multiply a model by a dimensionless factor.

    Parameters
    ----------
    factor : float
        Factor by which to scale a coordinate.

    Notes
    -----

    If ``factor`` is a `~astropy.units.Quantity` then the units will be
    stripped before the scaling operation.

    """
    factor = ...
    linear = ...
    fittable = ...
    _input_units_strict = ...
    _input_units_allow_dimensionless = ...
    _has_inverse_bounding_box = ...
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    
    @property
    def inverse(self): # -> Self@Scale:
        """One dimensional inverse Scale model function"""
        ...
    
    @staticmethod
    def evaluate(x, factor):
        """One dimensional Scale model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, *params): # -> list[Unknown]:
        """One dimensional Scale model derivative with respect to parameter"""
        ...
    


class Multiply(Fittable1DModel):
    """
    Multiply a model by a quantity or number.

    Parameters
    ----------
    factor : float
        Factor by which to multiply a coordinate.
    """
    factor = ...
    linear = ...
    fittable = ...
    _has_inverse_bounding_box = ...
    @property
    def inverse(self): # -> Self@Multiply:
        """One dimensional inverse multiply model function"""
        ...
    
    @staticmethod
    def evaluate(x, factor):
        """One dimensional multiply model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, *params): # -> list[Unknown]:
        """One dimensional multiply model derivative with respect to parameter"""
        ...
    


class RedshiftScaleFactor(Fittable1DModel):
    """
    One dimensional redshift scale factor model.

    Parameters
    ----------
    z : float
        Redshift value.

    Notes
    -----
    Model formula:

        .. math:: f(x) = x (1 + z)
    """
    z = ...
    _has_inverse_bounding_box = ...
    @staticmethod
    def evaluate(x, z):
        """One dimensional RedshiftScaleFactor model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, z): # -> list[Unknown]:
        """One dimensional RedshiftScaleFactor model derivative"""
        ...
    
    @property
    def inverse(self): # -> Self@RedshiftScaleFactor:
        """Inverse RedshiftScaleFactor model"""
        ...
    


class Sersic1D(Fittable1DModel):
    r"""
    One dimensional Sersic surface brightness profile.

    Parameters
    ----------
    amplitude : float
        Surface brightness at r_eff.
    r_eff : float
        Effective (half-light) radius
    n : float
        Sersic Index.

    See Also
    --------
    Gaussian1D, Moffat1D, Lorentz1D

    Notes
    -----
    Model formula:

    .. math::

        I(r)=I_e\exp\left\{-b_n\left[\left(\frac{r}{r_{e}}\right)^{(1/n)}-1\right]\right\}

    The constant :math:`b_n` is defined such that :math:`r_e` contains half the total
    luminosity, and can be solved for numerically.

    .. math::

        \Gamma(2n) = 2\gamma (b_n,2n)

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        from astropy.modeling.models import Sersic1D
        import matplotlib.pyplot as plt

        plt.figure()
        plt.subplot(111, xscale='log', yscale='log')
        s1 = Sersic1D(amplitude=1, r_eff=5)
        r=np.arange(0, 100, .01)

        for n in range(1, 10):
             s1.n = n
             plt.plot(r, s1(r), color=str(float(n) / 15))

        plt.axis([1e-1, 30, 1e-2, 1e3])
        plt.xlabel('log Radius')
        plt.ylabel('log Surface Brightness')
        plt.text(.25, 1.5, 'n=1')
        plt.text(.25, 300, 'n=10')
        plt.xticks([])
        plt.yticks([])
        plt.show()

    References
    ----------
    .. [1] http://ned.ipac.caltech.edu/level5/March05/Graham/Graham2.html
    """
    amplitude = ...
    r_eff = ...
    n = ...
    _gammaincinv = ...
    @classmethod
    def evaluate(cls, r, amplitude, r_eff, n):
        """One dimensional Sersic profile function."""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class _Trigonometric1D(Fittable1DModel):
    """
    Base class for one dimensional trigonometric and inverse trigonometric models

    Parameters
    ----------
    amplitude : float
        Oscillation amplitude
    frequency : float
        Oscillation frequency
    phase : float
        Oscillation phase
    """
    amplitude = ...
    frequency = ...
    phase = ...
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | _NotImplementedType] | None:
        ...
    


class Sine1D(_Trigonometric1D):
    """
    One dimensional Sine model.

    Parameters
    ----------
    amplitude : float
        Oscillation amplitude
    frequency : float
        Oscillation frequency
    phase : float
        Oscillation phase

    See Also
    --------
    ArcSine1D, Cosine1D, Tangent1D, Const1D, Linear1D


    Notes
    -----
    Model formula:

        .. math:: f(x) = A \\sin(2 \\pi f x + 2 \\pi p)

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import Sine1D

        plt.figure()
        s1 = Sine1D(amplitude=1, frequency=.25)
        r=np.arange(0, 10, .01)

        for amplitude in range(1,4):
             s1.amplitude = amplitude
             plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)

        plt.axis([0, 10, -5, 5])
        plt.show()
    """
    @staticmethod
    def evaluate(x, amplitude, frequency, phase):
        """One dimensional Sine model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, frequency, phase): # -> list[Any | Unknown]:
        """One dimensional Sine model derivative"""
        ...
    
    @property
    def inverse(self): # -> ArcSine1D:
        """One dimensional inverse of Sine"""
        ...
    


class Cosine1D(_Trigonometric1D):
    """
    One dimensional Cosine model.

    Parameters
    ----------
    amplitude : float
        Oscillation amplitude
    frequency : float
        Oscillation frequency
    phase : float
        Oscillation phase

    See Also
    --------
    ArcCosine1D, Sine1D, Tangent1D, Const1D, Linear1D


    Notes
    -----
    Model formula:

        .. math:: f(x) = A \\cos(2 \\pi f x + 2 \\pi p)

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import Cosine1D

        plt.figure()
        s1 = Cosine1D(amplitude=1, frequency=.25)
        r=np.arange(0, 10, .01)

        for amplitude in range(1,4):
             s1.amplitude = amplitude
             plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)

        plt.axis([0, 10, -5, 5])
        plt.show()
    """
    @staticmethod
    def evaluate(x, amplitude, frequency, phase):
        """One dimensional Cosine model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, frequency, phase): # -> list[Any | Unknown]:
        """One dimensional Cosine model derivative"""
        ...
    
    @property
    def inverse(self): # -> ArcCosine1D:
        """One dimensional inverse of Cosine"""
        ...
    


class Tangent1D(_Trigonometric1D):
    """
    One dimensional Tangent model.

    Parameters
    ----------
    amplitude : float
        Oscillation amplitude
    frequency : float
        Oscillation frequency
    phase : float
        Oscillation phase

    See Also
    --------
    Sine1D, Cosine1D, Const1D, Linear1D


    Notes
    -----
    Model formula:

        .. math:: f(x) = A \\tan(2 \\pi f x + 2 \\pi p)

    Note that the tangent function is undefined for inputs of the form
    pi/2 + n*pi for all integers n. Thus thus the default bounding box
    has been restricted to:

        .. math:: [(-1/4 - p)/f, (1/4 - p)/f]

    which is the smallest interval for the tangent function to be continuous
    on.

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import Tangent1D

        plt.figure()
        s1 = Tangent1D(amplitude=1, frequency=.25)
        r=np.arange(0, 10, .01)

        for amplitude in range(1,4):
             s1.amplitude = amplitude
             plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)

        plt.axis([0, 10, -5, 5])
        plt.show()
    """
    @staticmethod
    def evaluate(x, amplitude, frequency, phase):
        """One dimensional Tangent model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, frequency, phase): # -> list[Any | Unknown]:
        """One dimensional Tangent model derivative"""
        ...
    
    @property
    def inverse(self): # -> ArcTangent1D:
        """One dimensional inverse of Tangent"""
        ...
    
    def bounding_box(self): # -> _NotImplementedType | list[Unknown]:
        """
        Tuple defining the default ``bounding_box`` limits,
        ``(x_low, x_high)``
        """
        ...
    


class _InverseTrigonometric1D(_Trigonometric1D):
    """
    Base class for one dimensional inverse trigonometric models
    """
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class ArcSine1D(_InverseTrigonometric1D):
    """
    One dimensional ArcSine model returning values between -pi/2 and pi/2
    only.

    Parameters
    ----------
    amplitude : float
        Oscillation amplitude for corresponding Sine
    frequency : float
        Oscillation frequency for corresponding Sine
    phase : float
        Oscillation phase for corresponding Sine

    See Also
    --------
    Sine1D, ArcCosine1D, ArcTangent1D


    Notes
    -----
    Model formula:

        .. math:: f(x) = ((arcsin(x / A) / 2pi) - p) / f

    The arcsin function being used for this model will only accept inputs
    in [-A, A]; otherwise, a runtime warning will be thrown and the result
    will be NaN. To avoid this, the bounding_box has been properly set to
    accommodate this; therefore, it is recommended that this model always
    be evaluated with the ``with_bounding_box=True`` option.

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import ArcSine1D

        plt.figure()
        s1 = ArcSine1D(amplitude=1, frequency=.25)
        r=np.arange(-1, 1, .01)

        for amplitude in range(1,4):
             s1.amplitude = amplitude
             plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)

        plt.axis([-1, 1, -np.pi/2, np.pi/2])
        plt.show()
    """
    @staticmethod
    def evaluate(x, amplitude, frequency, phase):
        """One dimensional ArcSine model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, frequency, phase): # -> list[Unknown]:
        """One dimensional ArcSine model derivative"""
        ...
    
    def bounding_box(self): # -> tuple[Unknown, Unknown]:
        """
        Tuple defining the default ``bounding_box`` limits,
        ``(x_low, x_high)``
        """
        ...
    
    @property
    def inverse(self): # -> Sine1D:
        """One dimensional inverse of ArcSine"""
        ...
    


class ArcCosine1D(_InverseTrigonometric1D):
    """
    One dimensional ArcCosine returning values between 0 and pi only.


    Parameters
    ----------
    amplitude : float
        Oscillation amplitude for corresponding Cosine
    frequency : float
        Oscillation frequency for corresponding Cosine
    phase : float
        Oscillation phase for corresponding Cosine

    See Also
    --------
    Cosine1D, ArcSine1D, ArcTangent1D


    Notes
    -----
    Model formula:

        .. math:: f(x) = ((arccos(x / A) / 2pi) - p) / f

    The arccos function being used for this model will only accept inputs
    in [-A, A]; otherwise, a runtime warning will be thrown and the result
    will be NaN. To avoid this, the bounding_box has been properly set to
    accommodate this; therefore, it is recommended that this model always
    be evaluated with the ``with_bounding_box=True`` option.

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import ArcCosine1D

        plt.figure()
        s1 = ArcCosine1D(amplitude=1, frequency=.25)
        r=np.arange(-1, 1, .01)

        for amplitude in range(1,4):
             s1.amplitude = amplitude
             plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)

        plt.axis([-1, 1, 0, np.pi])
        plt.show()
    """
    @staticmethod
    def evaluate(x, amplitude, frequency, phase):
        """One dimensional ArcCosine model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, frequency, phase): # -> list[Unknown]:
        """One dimensional ArcCosine model derivative"""
        ...
    
    def bounding_box(self): # -> tuple[Unknown, Unknown]:
        """
        Tuple defining the default ``bounding_box`` limits,
        ``(x_low, x_high)``
        """
        ...
    
    @property
    def inverse(self): # -> Cosine1D:
        """One dimensional inverse of ArcCosine"""
        ...
    


class ArcTangent1D(_InverseTrigonometric1D):
    """
    One dimensional ArcTangent model returning values between -pi/2 and
    pi/2 only.

    Parameters
    ----------
    amplitude : float
        Oscillation amplitude for corresponding Tangent
    frequency : float
        Oscillation frequency for corresponding Tangent
    phase : float
        Oscillation phase for corresponding Tangent

    See Also
    --------
    Tangent1D, ArcSine1D, ArcCosine1D


    Notes
    -----
    Model formula:

        .. math:: f(x) = ((arctan(x / A) / 2pi) - p) / f

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import ArcTangent1D

        plt.figure()
        s1 = ArcTangent1D(amplitude=1, frequency=.25)
        r=np.arange(-10, 10, .01)

        for amplitude in range(1,4):
             s1.amplitude = amplitude
             plt.plot(r, s1(r), color=str(0.25 * amplitude), lw=2)

        plt.axis([-10, 10, -np.pi/2, np.pi/2])
        plt.show()
    """
    @staticmethod
    def evaluate(x, amplitude, frequency, phase):
        """One dimensional ArcTangent model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, frequency, phase): # -> list[Unknown]:
        """One dimensional ArcTangent model derivative"""
        ...
    
    @property
    def inverse(self): # -> Tangent1D:
        """One dimensional inverse of ArcTangent"""
        ...
    


class Linear1D(Fittable1DModel):
    """
    One dimensional Line model.

    Parameters
    ----------
    slope : float
        Slope of the straight line

    intercept : float
        Intercept of the straight line

    See Also
    --------
    Const1D

    Notes
    -----
    Model formula:

        .. math:: f(x) = a x + b
    """
    slope = ...
    intercept = ...
    linear = ...
    @staticmethod
    def evaluate(x, slope, intercept):
        """One dimensional Line model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, *params): # -> list[Unknown]:
        """One dimensional Line model derivative with respect to parameters"""
        ...
    
    @property
    def inverse(self): # -> Self@Linear1D:
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | _NotImplementedType] | None:
        ...
    


class Planar2D(Fittable2DModel):
    """
    Two dimensional Plane model.

    Parameters
    ----------
    slope_x : float
        Slope of the plane in X

    slope_y : float
        Slope of the plane in Y

    intercept : float
        Z-intercept of the plane

    Notes
    -----
    Model formula:

        .. math:: f(x, y) = a x + b y + c
    """
    slope_x = ...
    slope_y = ...
    intercept = ...
    linear = ...
    @staticmethod
    def evaluate(x, y, slope_x, slope_y, intercept):
        """Two dimensional Plane model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, y, *params): # -> list[Unknown]:
        """Two dimensional Plane model derivative with respect to parameters"""
        ...
    


class Lorentz1D(Fittable1DModel):
    """
    One dimensional Lorentzian model.

    Parameters
    ----------
    amplitude : float or `~astropy.units.Quantity`.
        Peak value - for a normalized profile (integrating to 1),
        set amplitude = 2 / (np.pi * fwhm)
    x_0 : float or `~astropy.units.Quantity`.
        Position of the peak
    fwhm : float or `~astropy.units.Quantity`.
        Full width at half maximum (FWHM)

    See Also
    --------
    Gaussian1D, Box1D, RickerWavelet1D

    Notes
    -----
    Either all or none of input ``x``, position ``x_0`` and ``fwhm`` must be provided
    consistently with compatible units or as unitless numbers.

    Model formula:

    .. math::

        f(x) = \\frac{A \\gamma^{2}}{\\gamma^{2} + \\left(x - x_{0}\\right)^{2}}

    where :math:`\\gamma` is half of given FWHM.

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import Lorentz1D

        plt.figure()
        s1 = Lorentz1D()
        r = np.arange(-5, 5, .01)

        for factor in range(1, 4):
            s1.amplitude = factor
            plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)

        plt.axis([-5, 5, -1, 4])
        plt.show()
    """
    amplitude = ...
    x_0 = ...
    fwhm = ...
    @staticmethod
    def evaluate(x, amplitude, x_0, fwhm):
        """One dimensional Lorentzian model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, x_0, fwhm): # -> list[Unknown]:
        """One dimensional Lorentzian model derivative with respect to parameters"""
        ...
    
    def bounding_box(self, factor=...): # -> tuple[Unknown, Unknown]:
        """Tuple defining the default ``bounding_box`` limits,
        ``(x_low, x_high)``.

        Parameters
        ----------
        factor : float
            The multiple of FWHM used to define the limits.
            Default is chosen to include most (99%) of the
            area under the curve, while still showing the
            central feature of interest.

        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Voigt1D(Fittable1DModel):
    """
    One dimensional model for the Voigt profile.

    Parameters
    ----------
    x_0 : float or `~astropy.units.Quantity`
        Position of the peak
    amplitude_L : float or `~astropy.units.Quantity`.
        The Lorentzian amplitude (peak of the associated Lorentz function)
        - for a normalized profile (integrating to 1), set
        amplitude_L = 2 / (np.pi * fwhm_L)
    fwhm_L : float or `~astropy.units.Quantity`
        The Lorentzian full width at half maximum
    fwhm_G : float or `~astropy.units.Quantity`.
        The Gaussian full width at half maximum
    method : str, optional
        Algorithm for computing the complex error function; one of
        'Humlicek2' (default, fast and generally more accurate than ``rtol=3.e-5``) or
        'Scipy', alternatively 'wofz' (requires ``scipy``, almost as fast and
        reference in accuracy).

    See Also
    --------
    Gaussian1D, Lorentz1D

    Notes
    -----
    Either all or none of input ``x``, position ``x_0`` and the ``fwhm_*`` must be provided
    consistently with compatible units or as unitless numbers.
    Voigt function is calculated as real part of the complex error function computed from either
    Humlicek's rational approximations (JQSRT 21:309, 1979; 27:437, 1982) following
    Schreier 2018 (MNRAS 479, 3068; and ``hum2zpf16m`` from his cpfX.py module); or
    `~scipy.special.wofz` (implementing 'Faddeeva.cc').

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        from astropy.modeling.models import Voigt1D
        import matplotlib.pyplot as plt

        plt.figure()
        x = np.arange(0, 10, 0.01)
        v1 = Voigt1D(x_0=5, amplitude_L=10, fwhm_L=0.5, fwhm_G=0.9)
        plt.plot(x, v1(x))
        plt.show()
    """
    x_0 = ...
    amplitude_L = ...
    fwhm_L = ...
    fwhm_G = ...
    sqrt_pi = ...
    sqrt_ln2 = ...
    sqrt_ln2pi = ...
    _last_z = np.zeros(1, dtype=complex)
    _last_w = np.zeros(1, dtype=float)
    _faddeeva = ...
    def __init__(self, x_0=..., amplitude_L=..., fwhm_L=..., fwhm_G=..., method=..., **kwargs) -> None:
        ...
    
    def evaluate(self, x, x_0, amplitude_L, fwhm_L, fwhm_G):
        """One dimensional Voigt function scaled to Lorentz peak amplitude."""
        ...
    
    def fit_deriv(self, x, x_0, amplitude_L, fwhm_L, fwhm_G): # -> list[Unknown]:
        """Derivative of the one dimensional Voigt function with respect to parameters."""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Const1D(Fittable1DModel):
    """
    One dimensional Constant model.

    Parameters
    ----------
    amplitude : float
        Value of the constant function

    See Also
    --------
    Const2D

    Notes
    -----
    Model formula:

        .. math:: f(x) = A

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import Const1D

        plt.figure()
        s1 = Const1D()
        r = np.arange(-5, 5, .01)

        for factor in range(1, 4):
            s1.amplitude = factor
            plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)

        plt.axis([-5, 5, -1, 4])
        plt.show()
    """
    amplitude = ...
    linear = ...
    @staticmethod
    def evaluate(x, amplitude): # -> Quantity:
        """One dimensional Constant model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude): # -> list[Unknown]:
        """One dimensional Constant model derivative with respect to parameters"""
        ...
    
    @property
    def input_units(self): # -> None:
        ...
    


class Const2D(Fittable2DModel):
    """
    Two dimensional Constant model.

    Parameters
    ----------
    amplitude : float
        Value of the constant function

    See Also
    --------
    Const1D

    Notes
    -----
    Model formula:

        .. math:: f(x, y) = A
    """
    amplitude = ...
    linear = ...
    @staticmethod
    def evaluate(x, y, amplitude): # -> Quantity:
        """Two dimensional Constant model function"""
        ...
    
    @property
    def input_units(self): # -> None:
        ...
    


class Ellipse2D(Fittable2DModel):
    """
    A 2D Ellipse model.

    Parameters
    ----------
    amplitude : float
        Value of the ellipse.

    x_0 : float
        x position of the center of the disk.

    y_0 : float
        y position of the center of the disk.

    a : float
        The length of the semimajor axis.

    b : float
        The length of the semiminor axis.

    theta : float or `~astropy.units.Quantity`, optional
        The rotation angle as an angular quantity
        (`~astropy.units.Quantity` or `~astropy.coordinates.Angle`)
        or a value in radians (as a float). The rotation angle
        increases counterclockwise from the positive x axis.

    See Also
    --------
    Disk2D, Box2D

    Notes
    -----
    Model formula:

    .. math::

        f(x, y) = \\left \\{
                    \\begin{array}{ll}
                      \\mathrm{amplitude} & : \\left[\\frac{(x - x_0) \\cos
                        \\theta + (y - y_0) \\sin \\theta}{a}\\right]^2 +
                        \\left[\\frac{-(x - x_0) \\sin \\theta + (y - y_0)
                        \\cos \\theta}{b}\\right]^2  \\leq 1 \\\\
                      0 & : \\mathrm{otherwise}
                    \\end{array}
                  \\right.

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        from astropy.modeling.models import Ellipse2D
        from astropy.coordinates import Angle
        import matplotlib.pyplot as plt
        import matplotlib.patches as mpatches
        x0, y0 = 25, 25
        a, b = 20, 10
        theta = Angle(30, 'deg')
        e = Ellipse2D(amplitude=100., x_0=x0, y_0=y0, a=a, b=b,
                      theta=theta.radian)
        y, x = np.mgrid[0:50, 0:50]
        fig, ax = plt.subplots(1, 1)
        ax.imshow(e(x, y), origin='lower', interpolation='none', cmap='Greys_r')
        e2 = mpatches.Ellipse((x0, y0), 2*a, 2*b, theta.degree, edgecolor='red',
                              facecolor='none')
        ax.add_patch(e2)
        plt.show()
    """
    amplitude = ...
    x_0 = ...
    y_0 = ...
    a = ...
    b = ...
    theta = ...
    @staticmethod
    def evaluate(x, y, amplitude, x_0, y_0, a, b, theta): # -> Quantity | NDArray[Any]:
        """Two dimensional Ellipse model function."""
        ...
    
    @property
    def bounding_box(self): # -> tuple[tuple[Any, Any], tuple[Any, Any]]:
        """
        Tuple defining the default ``bounding_box`` limits.

        ``((y_low, y_high), (x_low, x_high))``
        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Disk2D(Fittable2DModel):
    """
    Two dimensional radial symmetric Disk model.

    Parameters
    ----------
    amplitude : float
        Value of the disk function
    x_0 : float
        x position center of the disk
    y_0 : float
        y position center of the disk
    R_0 : float
        Radius of the disk

    See Also
    --------
    Box2D, TrapezoidDisk2D

    Notes
    -----
    Model formula:

        .. math::

            f(r) = \\left \\{
                     \\begin{array}{ll}
                       A & : r \\leq R_0 \\\\
                       0 & : r > R_0
                     \\end{array}
                   \\right.
    """
    amplitude = ...
    x_0 = ...
    y_0 = ...
    R_0 = ...
    @staticmethod
    def evaluate(x, y, amplitude, x_0, y_0, R_0): # -> Quantity | NDArray[Any]:
        """Two dimensional Disk model function"""
        ...
    
    @property
    def bounding_box(self): # -> tuple[tuple[Unknown, Unknown], tuple[Unknown, Unknown]]:
        """
        Tuple defining the default ``bounding_box`` limits.

        ``((y_low, y_high), (x_low, x_high))``
        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Ring2D(Fittable2DModel):
    """
    Two dimensional radial symmetric Ring model.

    Parameters
    ----------
    amplitude : float
        Value of the disk function
    x_0 : float
        x position center of the disk
    y_0 : float
        y position center of the disk
    r_in : float
        Inner radius of the ring
    width : float
        Width of the ring.
    r_out : float
        Outer Radius of the ring. Can be specified instead of width.

    See Also
    --------
    Disk2D, TrapezoidDisk2D

    Notes
    -----
    Model formula:

        .. math::

            f(r) = \\left \\{
                     \\begin{array}{ll}
                       A & : r_{in} \\leq r \\leq r_{out} \\\\
                       0 & : \\text{else}
                     \\end{array}
                   \\right.

    Where :math:`r_{out} = r_{in} + r_{width}`.
    """
    amplitude = ...
    x_0 = ...
    y_0 = ...
    r_in = ...
    width = ...
    def __init__(self, amplitude=..., x_0=..., y_0=..., r_in=..., width=..., r_out=..., **kwargs) -> None:
        ...
    
    @staticmethod
    def evaluate(x, y, amplitude, x_0, y_0, r_in, width): # -> Quantity | NDArray[Any]:
        """Two dimensional Ring model function."""
        ...
    
    @property
    def bounding_box(self): # -> tuple[tuple[Unknown, Unknown], tuple[Unknown, Unknown]]:
        """
        Tuple defining the default ``bounding_box``.

        ``((y_low, y_high), (x_low, x_high))``
        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Box1D(Fittable1DModel):
    """
    One dimensional Box model.

    Parameters
    ----------
    amplitude : float
        Amplitude A
    x_0 : float
        Position of the center of the box function
    width : float
        Width of the box

    See Also
    --------
    Box2D, TrapezoidDisk2D

    Notes
    -----
    Model formula:

      .. math::

            f(x) = \\left \\{
                     \\begin{array}{ll}
                       A & : x_0 - w/2 \\leq x \\leq x_0 + w/2 \\\\
                       0 & : \\text{else}
                     \\end{array}
                   \\right.

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import Box1D

        plt.figure()
        s1 = Box1D()
        r = np.arange(-5, 5, .01)

        for factor in range(1, 4):
            s1.amplitude = factor
            s1.width = factor
            plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)

        plt.axis([-5, 5, -1, 4])
        plt.show()
    """
    amplitude = ...
    x_0 = ...
    width = ...
    @staticmethod
    def evaluate(x, amplitude, x_0, width): # -> NDArray[Any]:
        """One dimensional Box model function"""
        ...
    
    @property
    def bounding_box(self): # -> tuple[Unknown, Unknown]:
        """
        Tuple defining the default ``bounding_box`` limits.

        ``(x_low, x_high))``
        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    
    @property
    def return_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Box2D(Fittable2DModel):
    """
    Two dimensional Box model.

    Parameters
    ----------
    amplitude : float
        Amplitude
    x_0 : float
        x position of the center of the box function
    x_width : float
        Width in x direction of the box
    y_0 : float
        y position of the center of the box function
    y_width : float
        Width in y direction of the box

    See Also
    --------
    Box1D, Gaussian2D, Moffat2D

    Notes
    -----
    Model formula:

      .. math::

            f(x, y) = \\left \\{
                     \\begin{array}{ll}
            A : & x_0 - w_x/2 \\leq x \\leq x_0 + w_x/2 \\text{ and} \\\\
                & y_0 - w_y/2 \\leq y \\leq y_0 + w_y/2 \\\\
            0 : & \\text{else}
                     \\end{array}
                   \\right.

    """
    amplitude = ...
    x_0 = ...
    y_0 = ...
    x_width = ...
    y_width = ...
    @staticmethod
    def evaluate(x, y, amplitude, x_0, y_0, x_width, y_width): # -> Quantity | NDArray[Any]:
        """Two dimensional Box model function"""
        ...
    
    @property
    def bounding_box(self): # -> tuple[tuple[Unknown, Unknown], tuple[Unknown, Unknown]]:
        """
        Tuple defining the default ``bounding_box``.

        ``((y_low, y_high), (x_low, x_high))``
        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Trapezoid1D(Fittable1DModel):
    """
    One dimensional Trapezoid model.

    Parameters
    ----------
    amplitude : float
        Amplitude of the trapezoid
    x_0 : float
        Center position of the trapezoid
    width : float
        Width of the constant part of the trapezoid.
    slope : float
        Slope of the tails of the trapezoid

    See Also
    --------
    Box1D, Gaussian1D, Moffat1D

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import Trapezoid1D

        plt.figure()
        s1 = Trapezoid1D()
        r = np.arange(-5, 5, .01)

        for factor in range(1, 4):
            s1.amplitude = factor
            s1.width = factor
            plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)

        plt.axis([-5, 5, -1, 4])
        plt.show()
    """
    amplitude = ...
    x_0 = ...
    width = ...
    slope = ...
    @staticmethod
    def evaluate(x, amplitude, x_0, width, slope): # -> Quantity | NDArray[Any]:
        """One dimensional Trapezoid model function"""
        ...
    
    @property
    def bounding_box(self): # -> tuple[Unknown, Unknown]:
        """
        Tuple defining the default ``bounding_box`` limits.

        ``(x_low, x_high))``
        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class TrapezoidDisk2D(Fittable2DModel):
    """
    Two dimensional circular Trapezoid model.

    Parameters
    ----------
    amplitude : float
        Amplitude of the trapezoid
    x_0 : float
        x position of the center of the trapezoid
    y_0 : float
        y position of the center of the trapezoid
    R_0 : float
        Radius of the constant part of the trapezoid.
    slope : float
        Slope of the tails of the trapezoid in x direction.

    See Also
    --------
    Disk2D, Box2D
    """
    amplitude = ...
    x_0 = ...
    y_0 = ...
    R_0 = ...
    slope = ...
    @staticmethod
    def evaluate(x, y, amplitude, x_0, y_0, R_0, slope): # -> Quantity | NDArray[Any]:
        """Two dimensional Trapezoid Disk model function"""
        ...
    
    @property
    def bounding_box(self): # -> tuple[tuple[Unknown, Unknown], tuple[Unknown, Unknown]]:
        """
        Tuple defining the default ``bounding_box``.

        ``((y_low, y_high), (x_low, x_high))``
        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class RickerWavelet1D(Fittable1DModel):
    """
    One dimensional Ricker Wavelet model (sometimes known as a "Mexican Hat"
    model).

    .. note::

        See https://github.com/astropy/astropy/pull/9445 for discussions
        related to renaming of this model.

    Parameters
    ----------
    amplitude : float
        Amplitude
    x_0 : float
        Position of the peak
    sigma : float
        Width of the Ricker wavelet

    See Also
    --------
    RickerWavelet2D, Box1D, Gaussian1D, Trapezoid1D

    Notes
    -----
    Model formula:

    .. math::

        f(x) = {A \\left(1 - \\frac{\\left(x - x_{0}\\right)^{2}}{\\sigma^{2}}\\right)
        e^{- \\frac{\\left(x - x_{0}\\right)^{2}}{2 \\sigma^{2}}}}

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import RickerWavelet1D

        plt.figure()
        s1 = RickerWavelet1D()
        r = np.arange(-5, 5, .01)

        for factor in range(1, 4):
            s1.amplitude = factor
            s1.width = factor
            plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)

        plt.axis([-5, 5, -2, 4])
        plt.show()
    """
    amplitude = ...
    x_0 = ...
    sigma = ...
    @staticmethod
    def evaluate(x, amplitude, x_0, sigma):
        """One dimensional Ricker Wavelet model function"""
        ...
    
    def bounding_box(self, factor=...): # -> tuple[Unknown, Unknown]:
        """Tuple defining the default ``bounding_box`` limits,
        ``(x_low, x_high)``.

        Parameters
        ----------
        factor : float
            The multiple of sigma used to define the limits.

        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class RickerWavelet2D(Fittable2DModel):
    """
    Two dimensional Ricker Wavelet model (sometimes known as a "Mexican Hat"
    model).

    .. note::

        See https://github.com/astropy/astropy/pull/9445 for discussions
        related to renaming of this model.

    Parameters
    ----------
    amplitude : float
        Amplitude
    x_0 : float
        x position of the peak
    y_0 : float
        y position of the peak
    sigma : float
        Width of the Ricker wavelet

    See Also
    --------
    RickerWavelet1D, Gaussian2D

    Notes
    -----
    Model formula:

    .. math::

        f(x, y) = A \\left(1 - \\frac{\\left(x - x_{0}\\right)^{2}
        + \\left(y - y_{0}\\right)^{2}}{\\sigma^{2}}\\right)
        e^{\\frac{- \\left(x - x_{0}\\right)^{2}
        - \\left(y - y_{0}\\right)^{2}}{2 \\sigma^{2}}}
    """
    amplitude = ...
    x_0 = ...
    y_0 = ...
    sigma = ...
    @staticmethod
    def evaluate(x, y, amplitude, x_0, y_0, sigma):
        """Two dimensional Ricker Wavelet model function"""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class AiryDisk2D(Fittable2DModel):
    """
    Two dimensional Airy disk model.

    Parameters
    ----------
    amplitude : float
        Amplitude of the Airy function.
    x_0 : float
        x position of the maximum of the Airy function.
    y_0 : float
        y position of the maximum of the Airy function.
    radius : float
        The radius of the Airy disk (radius of the first zero).

    See Also
    --------
    Box2D, TrapezoidDisk2D, Gaussian2D

    Notes
    -----
    Model formula:

        .. math:: f(r) = A \\left[
                \\frac{2 J_1(\\frac{\\pi r}{R/R_z})}{\\frac{\\pi r}{R/R_z}}
            \\right]^2

    Where :math:`J_1` is the first order Bessel function of the first
    kind, :math:`r` is radial distance from the maximum of the Airy
    function (:math:`r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}`), :math:`R`
    is the input ``radius`` parameter, and :math:`R_z =
    1.2196698912665045`).

    For an optical system, the radius of the first zero represents the
    limiting angular resolution and is approximately 1.22 * lambda / D,
    where lambda is the wavelength of the light and D is the diameter of
    the aperture.

    See [1]_ for more details about the Airy disk.

    References
    ----------
    .. [1] https://en.wikipedia.org/wiki/Airy_disk
    """
    amplitude = ...
    x_0 = ...
    y_0 = ...
    radius = ...
    _rz = ...
    _j1 = ...
    @classmethod
    def evaluate(cls, x, y, amplitude, x_0, y_0, radius): # -> Quantity | NDArray[bool_] | NDArray[floating[_64Bit]]:
        """Two dimensional Airy model function"""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Moffat1D(Fittable1DModel):
    """
    One dimensional Moffat model.

    Parameters
    ----------
    amplitude : float
        Amplitude of the model.
    x_0 : float
        x position of the maximum of the Moffat model.
    gamma : float
        Core width of the Moffat model.
    alpha : float
        Power index of the Moffat model.

    See Also
    --------
    Gaussian1D, Box1D

    Notes
    -----
    Model formula:

    .. math::

        f(x) = A \\left(1 + \\frac{\\left(x - x_{0}\\right)^{2}}{\\gamma^{2}}\\right)^{- \\alpha}

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        import matplotlib.pyplot as plt

        from astropy.modeling.models import Moffat1D

        plt.figure()
        s1 = Moffat1D()
        r = np.arange(-5, 5, .01)

        for factor in range(1, 4):
            s1.amplitude = factor
            s1.width = factor
            plt.plot(r, s1(r), color=str(0.25 * factor), lw=2)

        plt.axis([-5, 5, -1, 4])
        plt.show()
    """
    amplitude = ...
    x_0 = ...
    gamma = ...
    alpha = ...
    @property
    def fwhm(self): # -> Any:
        """
        Moffat full width at half maximum.
        Derivation of the formula is available in
        `this notebook by Yoonsoo Bach
        <https://nbviewer.jupyter.org/github/ysbach/AO_2017/blob/master/04_Ground_Based_Concept.ipynb#1.2.-Moffat>`_.
        """
        ...
    
    @staticmethod
    def evaluate(x, amplitude, x_0, gamma, alpha):
        """One dimensional Moffat model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, x_0, gamma, alpha): # -> list[Unknown]:
        """One dimensional Moffat model derivative with respect to parameters"""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Moffat2D(Fittable2DModel):
    """
    Two dimensional Moffat model.

    Parameters
    ----------
    amplitude : float
        Amplitude of the model.
    x_0 : float
        x position of the maximum of the Moffat model.
    y_0 : float
        y position of the maximum of the Moffat model.
    gamma : float
        Core width of the Moffat model.
    alpha : float
        Power index of the Moffat model.

    See Also
    --------
    Gaussian2D, Box2D

    Notes
    -----
    Model formula:

    .. math::

        f(x, y) = A \\left(1 + \\frac{\\left(x - x_{0}\\right)^{2} +
        \\left(y - y_{0}\\right)^{2}}{\\gamma^{2}}\\right)^{- \\alpha}
    """
    amplitude = ...
    x_0 = ...
    y_0 = ...
    gamma = ...
    alpha = ...
    @property
    def fwhm(self): # -> Any:
        """
        Moffat full width at half maximum.
        Derivation of the formula is available in
        `this notebook by Yoonsoo Bach
        <https://nbviewer.jupyter.org/github/ysbach/AO_2017/blob/master/04_Ground_Based_Concept.ipynb#1.2.-Moffat>`_.
        """
        ...
    
    @staticmethod
    def evaluate(x, y, amplitude, x_0, y_0, gamma, alpha):
        """Two dimensional Moffat model function"""
        ...
    
    @staticmethod
    def fit_deriv(x, y, amplitude, x_0, y_0, gamma, alpha): # -> list[Unknown]:
        """Two dimensional Moffat model derivative with respect to parameters"""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Sersic2D(Fittable2DModel):
    r"""
    Two dimensional Sersic surface brightness profile.

    Parameters
    ----------
    amplitude : float
        Surface brightness at r_eff.
    r_eff : float
        Effective (half-light) radius
    n : float
        Sersic Index.
    x_0 : float, optional
        x position of the center.
    y_0 : float, optional
        y position of the center.
    ellip : float, optional
        Ellipticity.
    theta : float or `~astropy.units.Quantity`, optional
        The rotation angle as an angular quantity
        (`~astropy.units.Quantity` or `~astropy.coordinates.Angle`)
        or a value in radians (as a float). The rotation angle
        increases counterclockwise from the positive x axis.

    See Also
    --------
    Gaussian2D, Moffat2D

    Notes
    -----
    Model formula:

    .. math::

        I(x,y) = I(r) = I_e\exp\left\{
                -b_n\left[\left(\frac{r}{r_{e}}\right)^{(1/n)}-1\right]
            \right\}

    The constant :math:`b_n` is defined such that :math:`r_e` contains half the total
    luminosity, and can be solved for numerically.

    .. math::

        \Gamma(2n) = 2\gamma (2n,b_n)

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        from astropy.modeling.models import Sersic2D
        import matplotlib.pyplot as plt

        x,y = np.meshgrid(np.arange(100), np.arange(100))

        mod = Sersic2D(amplitude = 1, r_eff = 25, n=4, x_0=50, y_0=50,
                       ellip=.5, theta=-1)
        img = mod(x, y)
        log_img = np.log10(img)


        plt.figure()
        plt.imshow(log_img, origin='lower', interpolation='nearest',
                   vmin=-1, vmax=2)
        plt.xlabel('x')
        plt.ylabel('y')
        cbar = plt.colorbar()
        cbar.set_label('Log Brightness', rotation=270, labelpad=25)
        cbar.set_ticks([-1, 0, 1, 2], update_ticks=True)
        plt.show()

    References
    ----------
    .. [1] http://ned.ipac.caltech.edu/level5/March05/Graham/Graham2.html
    """
    amplitude = ...
    r_eff = ...
    n = ...
    x_0 = ...
    y_0 = ...
    ellip = ...
    theta = ...
    _gammaincinv = ...
    @classmethod
    def evaluate(cls, x, y, amplitude, r_eff, n, x_0, y_0, ellip, theta):
        """Two dimensional Sersic profile function."""
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class KingProjectedAnalytic1D(Fittable1DModel):
    """
    Projected (surface density) analytic King Model.


    Parameters
    ----------
    amplitude : float
        Amplitude or scaling factor.
    r_core : float
        Core radius (f(r_c) ~ 0.5 f_0)
    r_tide : float
        Tidal radius.


    Notes
    -----

    This model approximates a King model with an analytic function. The derivation of this
    equation can be found in King '62 (equation 14). This is just an approximation of the
    full model and the parameters derived from this model should be taken with caution.
    It usually works for models with a concentration (c = log10(r_t/r_c) parameter < 2.

    Model formula:

    .. math::

        f(x) = A r_c^2  \\left(\\frac{1}{\\sqrt{(x^2 + r_c^2)}} -
        \\frac{1}{\\sqrt{(r_t^2 + r_c^2)}}\\right)^2

    Examples
    --------
    .. plot::
        :include-source:

        import numpy as np
        from astropy.modeling.models import KingProjectedAnalytic1D
        import matplotlib.pyplot as plt

        plt.figure()
        rt_list = [1, 2, 5, 10, 20]
        for rt in rt_list:
            r = np.linspace(0.1, rt, 100)

            mod = KingProjectedAnalytic1D(amplitude = 1, r_core = 1., r_tide = rt)
            sig = mod(r)


            plt.loglog(r, sig/sig[0], label=f"c ~ {mod.concentration:0.2f}")

        plt.xlabel("r")
        plt.ylabel(r"$\\sigma/\\sigma_0$")
        plt.legend()
        plt.show()

    References
    ----------
    .. [1] https://ui.adsabs.harvard.edu/abs/1962AJ.....67..471K
    """
    amplitude = ...
    r_core = ...
    r_tide = ...
    @property
    def concentration(self): # -> Any:
        """Concentration parameter of the king model"""
        ...
    
    @staticmethod
    def evaluate(x, amplitude, r_core, r_tide):
        """
        Analytic King model function.
        """
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, r_core, r_tide): # -> list[Unknown]:
        """
        Analytic King model function derivatives.
        """
        ...
    
    @property
    def bounding_box(self): # -> tuple[Unknown, Unknown]:
        """
        Tuple defining the default ``bounding_box`` limits.

        The model is not defined for r > r_tide.

        ``(r_low, r_high)``
        """
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Logarithmic1D(Fittable1DModel):
    """
    One dimensional logarithmic model.

    Parameters
    ----------
    amplitude : float, optional
    tau : float, optional

    See Also
    --------
    Exponential1D, Gaussian1D
    """
    amplitude = ...
    tau = ...
    @staticmethod
    def evaluate(x, amplitude, tau):
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, tau): # -> list[Any | Unknown]:
        ...
    
    @property
    def inverse(self): # -> Exponential1D:
        ...
    
    @tau.validator
    def tau(self, val): # -> None:
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


class Exponential1D(Fittable1DModel):
    """
    One dimensional exponential model.

    Parameters
    ----------
    amplitude : float, optional
    tau : float, optional

    See Also
    --------
    Logarithmic1D, Gaussian1D
    """
    amplitude = ...
    tau = ...
    @staticmethod
    def evaluate(x, amplitude, tau):
        ...
    
    @staticmethod
    def fit_deriv(x, amplitude, tau): # -> list[Any | Unknown]:
        ''' Derivative with respect to parameters'''
        ...
    
    @property
    def inverse(self): # -> Logarithmic1D:
        ...
    
    @tau.validator
    def tau(self, val): # -> None:
        ''' tau cannot be 0'''
        ...
    
    @property
    def input_units(self): # -> dict[str | Any | Unknown, Unknown | MagUnit] | None:
        ...
    


