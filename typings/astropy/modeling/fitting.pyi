"""
This type stub file was generated by pyright.
"""

import abc

"""
This module implements classes (called Fitters) which combine optimization
algorithms (typically from `scipy.optimize`) with statistic functions to perform
fitting. Fitters are implemented as callable classes. In addition to the data
to fit, the ``__call__`` method takes an instance of
`~astropy.modeling.core.FittableModel` as input, and returns a copy of the
model with its parameters determined by the optimizer.

Optimization algorithms, called "optimizers" are implemented in
`~astropy.modeling.optimizers` and statistic functions are in
`~astropy.modeling.statistic`. The goal is to provide an easy to extend
framework and allow users to easily create new fitters by combining statistics
with optimizers.

There are two exceptions to the above scheme.
`~astropy.modeling.fitting.LinearLSQFitter` uses Numpy's `~numpy.linalg.lstsq`
function.  `~astropy.modeling.fitting.LevMarLSQFitter` uses
`~scipy.optimize.leastsq` which combines optimization and statistic in one
implementation.
"""
__all__ = ['LinearLSQFitter', 'LevMarLSQFitter', 'TRFLSQFitter', 'DogBoxLSQFitter', 'LMLSQFitter', 'FittingWithOutlierRemoval', 'SLSQPLSQFitter', 'SimplexLSQFitter', 'JointFitter', 'Fitter', 'ModelLinearityError', "ModelsError"]
STATISTICS = ...
OPTIMIZERS = ...
class NonFiniteValueError(RuntimeError):
    """
    Error raised when attempting to a non-finite value
    """
    ...


class Covariance:
    """Class for covariance matrix calculated by fitter. """
    def __init__(self, cov_matrix, param_names) -> None:
        ...
    
    def pprint(self, max_lines, round_val): # -> str | LiteralString:
        ...
    
    def __repr__(self): # -> str | LiteralString:
        ...
    
    def __getitem__(self, params):
        ...
    


class StandardDeviations:
    """ Class for fitting uncertainties."""
    def __init__(self, cov_matrix, param_names) -> None:
        ...
    
    def pprint(self, max_lines, round_val): # -> str | LiteralString:
        ...
    
    def __repr__(self): # -> str | LiteralString:
        ...
    
    def __getitem__(self, param): # -> Any | None:
        ...
    


class ModelsError(Exception):
    """Base class for model exceptions"""
    ...


class ModelLinearityError(ModelsError):
    """ Raised when a non-linear model is passed to a linear fitter."""
    ...


class UnsupportedConstraintError(ModelsError, ValueError):
    """
    Raised when a fitter does not support a type of constraint.
    """
    ...


class _FitterMeta(abc.ABCMeta):
    """
    Currently just provides a registry for all Fitter classes.
    """
    registry = ...
    def __new__(mcls, name, bases, members): # -> Self@_FitterMeta:
        ...
    


def fitter_unit_support(func): # -> (self: Unknown, model: Unknown, x: Unknown, y: Unknown, z: Unknown | None = None, **kwargs: Unknown) -> Unknown:
    """
    This is a decorator that can be used to add support for dealing with
    quantities to any __call__ method on a fitter which may not support
    quantities itself. This is done by temporarily removing units from all
    parameters then adding them back once the fitting has completed.
    """
    ...

class Fitter(metaclass=_FitterMeta):
    """
    Base class for all fitters.

    Parameters
    ----------
    optimizer : callable
        A callable implementing an optimization algorithm
    statistic : callable
        Statistic function

    """
    supported_constraints = ...
    def __init__(self, optimizer, statistic) -> None:
        ...
    
    def objective_function(self, fps, *args): # -> Any:
        """
        Function to minimize.

        Parameters
        ----------
        fps : list
            parameters returned by the fitter
        args : list
            [model, [other_args], [input coordinates]]
            other_args may include weights or any other quantities specific for
            a statistic

        Notes
        -----
        The list of arguments (args) is set in the `__call__` method.
        Fitters may overwrite this method, e.g. when statistic functions
        require other arguments.

        """
        ...
    
    @abc.abstractmethod
    def __call__(self):
        """
        This method performs the actual fitting and modifies the parameter list
        of a model.
        Fitter subclasses should implement this method.
        """
        ...
    


class LinearLSQFitter(metaclass=_FitterMeta):
    """
    A class performing a linear least square fitting.
    Uses `numpy.linalg.lstsq` to do the fitting.
    Given a model and data, fits the model to the data and changes the
    model's parameters. Keeps a dictionary of auxiliary fitting information.
    Notes
    -----
    Note that currently LinearLSQFitter does not support compound models.
    """
    supported_constraints = ...
    supports_masked_input = ...
    def __init__(self, calc_uncertainties=...) -> None:
        ...
    
    @fitter_unit_support
    def __call__(self, model, x, y, z=..., weights=..., rcond=...):
        """
        Fit data to this model.

        Parameters
        ----------
        model : `~astropy.modeling.FittableModel`
            model to fit to x, y, z
        x : array
            Input coordinates
        y : array-like
            Input coordinates
        z : array-like, optional
            Input coordinates.
            If the dependent (``y`` or ``z``) coordinate values are provided
            as a `numpy.ma.MaskedArray`, any masked points are ignored when
            fitting. Note that model set fitting is significantly slower when
            there are masked points (not just an empty mask), as the matrix
            equation has to be solved for each model separately when their
            coordinate grids differ.
        weights : array, optional
            Weights for fitting.
            For data with Gaussian uncertainties, the weights should be
            1/sigma.
        rcond :  float, optional
            Cut-off ratio for small singular values of ``a``.
            Singular values are set to zero if they are smaller than ``rcond``
            times the largest singular value of ``a``.
        equivalencies : list or None, optional, keyword-only
            List of *additional* equivalencies that are should be applied in
            case x, y and/or z have units. Default is None.

        Returns
        -------
        model_copy : `~astropy.modeling.FittableModel`
            a copy of the input model with parameters set by the fitter

        """
        ...
    


class FittingWithOutlierRemoval:
    """
    This class combines an outlier removal technique with a fitting procedure.
    Basically, given a maximum number of iterations ``niter``, outliers are
    removed and fitting is performed for each iteration, until no new outliers
    are found or ``niter`` is reached.

    Parameters
    ----------
    fitter : `Fitter`
        An instance of any Astropy fitter, i.e., LinearLSQFitter,
        LevMarLSQFitter, SLSQPLSQFitter, SimplexLSQFitter, JointFitter. For
        model set fitting, this must understand masked input data (as
        indicated by the fitter class attribute ``supports_masked_input``).
    outlier_func : callable
        A function for outlier removal.
        If this accepts an ``axis`` parameter like the `numpy` functions, the
        appropriate value will be supplied automatically when fitting model
        sets (unless overridden in ``outlier_kwargs``), to find outliers for
        each model separately; otherwise, the same filtering must be performed
        in a loop over models, which is almost an order of magnitude slower.
    niter : int, optional
        Maximum number of iterations.
    outlier_kwargs : dict, optional
        Keyword arguments for outlier_func.

    Attributes
    ----------
    fit_info : dict
        The ``fit_info`` (if any) from the last iteration of the wrapped
        ``fitter`` during the most recent fit. An entry is also added with the
        keyword ``niter`` that records the actual number of fitting iterations
        performed (as opposed to the user-specified maximum).
    """
    def __init__(self, fitter, outlier_func, niter=..., **outlier_kwargs) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __call__(self, model, x, y, z=..., weights=..., **kwargs): # -> tuple[Unknown, Unknown | Literal[False]]:
        """
        Parameters
        ----------
        model : `~astropy.modeling.FittableModel`
            An analytic model which will be fit to the provided data.
            This also contains the initial guess for an optimization
            algorithm.
        x : array-like
            Input coordinates.
        y : array-like
            Data measurements (1D case) or input coordinates (2D case).
        z : array-like, optional
            Data measurements (2D case).
        weights : array-like, optional
            Weights to be passed to the fitter.
        kwargs : dict, optional
            Keyword arguments to be passed to the fitter.
        Returns
        -------
        fitted_model : `~astropy.modeling.FittableModel`
            Fitted model after outlier removal.
        mask : `numpy.ndarray`
            Boolean mask array, identifying which points were used in the final
            fitting iteration (False) and which were found to be outliers or
            were masked in the input (True).
        """
        ...
    


class _NonLinearLSQFitter(metaclass=_FitterMeta):
    """
    Base class for Non-Linear least-squares fitters

    Parameters
    ----------
    calc_uncertainties : bool
        If the covarience matrix should be computed and set in the fit_info.
        Default: False
    use_min_max_bounds : bool
        If the set parameter bounds for a model will be enforced each given
        parameter while fitting via a simple min/max condition.
        Default: True
    """
    supported_constraints = ...
    def __init__(self, calc_uncertainties=..., use_min_max_bounds=...) -> None:
        ...
    
    def objective_function(self, fps, *args): # -> NDArray[Unknown]:
        """
        Function to minimize.

        Parameters
        ----------
        fps : list
            parameters returned by the fitter
        args : list
            [model, [weights], [input coordinates]]

        """
        ...
    
    @fitter_unit_support
    def __call__(self, model, x, y, z=..., weights=..., maxiter=..., acc=..., epsilon=..., estimate_jacobian=...):
        """
        Fit data to this model.

        Parameters
        ----------
        model : `~astropy.modeling.FittableModel`
            model to fit to x, y, z
        x : array
           input coordinates
        y : array
           input coordinates
        z : array, optional
           input coordinates
        weights : array, optional
            Weights for fitting.
            For data with Gaussian uncertainties, the weights should be
            1/sigma.
        maxiter : int
            maximum number of iterations
        acc : float
            Relative error desired in the approximate solution
        epsilon : float
            A suitable step length for the forward-difference
            approximation of the Jacobian (if model.fjac=None). If
            epsfcn is less than the machine precision, it is
            assumed that the relative errors in the functions are
            of the order of the machine precision.
        estimate_jacobian : bool
            If False (default) and if the model has a fit_deriv method,
            it will be used. Otherwise the Jacobian will be estimated.
            If True, the Jacobian will be estimated in any case.
        equivalencies : list or None, optional, keyword-only
            List of *additional* equivalencies that are should be applied in
            case x, y and/or z have units. Default is None.

        Returns
        -------
        model_copy : `~astropy.modeling.FittableModel`
            a copy of the input model with parameters set by the fitter

        """
        ...
    


class LevMarLSQFitter(_NonLinearLSQFitter):
    """
    Levenberg-Marquardt algorithm and least squares statistic.

    Parameters
    ----------
    calc_uncertainties : bool
        If the covarience matrix should be computed and set in the fit_info.
        Default: False

    Attributes
    ----------
    fit_info : dict
        The `scipy.optimize.leastsq` result for the most recent fit (see
        notes).

    Notes
    -----
    The ``fit_info`` dictionary contains the values returned by
    `scipy.optimize.leastsq` for the most recent fit, including the values from
    the ``infodict`` dictionary it returns. See the `scipy.optimize.leastsq`
    documentation for details on the meaning of these values. Note that the
    ``x`` return value is *not* included (as it is instead the parameter values
    of the returned model).
    Additionally, one additional element of ``fit_info`` is computed whenever a
    model is fit, with the key 'param_cov'. The corresponding value is the
    covariance matrix of the parameters as a 2D numpy array.  The order of the
    matrix elements matches the order of the parameters in the fitted model
    (i.e., the same order as ``model.param_names``).

    """
    def __init__(self, calc_uncertainties=...) -> None:
        ...
    


class _NLLSQFitter(_NonLinearLSQFitter):
    """
    Wrapper class for `scipy.optimize.least_squares` method, which provides:
        - Trust Region Reflective
        - dogbox
        - Levenberg-Marqueardt
    algorithms using the least squares statistic.

    Parameters
    ----------
    method : str
        ‘trf’ :  Trust Region Reflective algorithm, particularly suitable
            for large sparse problems with bounds. Generally robust method.
        ‘dogbox’ : dogleg algorithm with rectangular trust regions, typical
            use case is small problems with bounds. Not recommended for
            problems with rank-deficient Jacobian.
        ‘lm’ : Levenberg-Marquardt algorithm as implemented in MINPACK.
            Doesn’t handle bounds and sparse Jacobians. Usually the most
            efficient method for small unconstrained problems.
    calc_uncertainties : bool
        If the covarience matrix should be computed and set in the fit_info.
        Default: False
    use_min_max_bounds: bool
        If the set parameter bounds for a model will be enforced each given
        parameter while fitting via a simple min/max condition. A True setting
        will replicate how LevMarLSQFitter enforces bounds.
        Default: False

    Attributes
    ----------
    fit_info :
        A `scipy.optimize.OptimizeResult` class which contains all of
        the most recent fit information
    """
    def __init__(self, method, calc_uncertainties=..., use_min_max_bounds=...) -> None:
        ...
    


class TRFLSQFitter(_NLLSQFitter):
    """
    Trust Region Reflective algorithm and least squares statistic.

    Parameters
    ----------
    calc_uncertainties : bool
        If the covarience matrix should be computed and set in the fit_info.
        Default: False
    use_min_max_bounds: bool
        If the set parameter bounds for a model will be enforced each given
        parameter while fitting via a simple min/max condition. A True setting
        will replicate how LevMarLSQFitter enforces bounds.
        Default: False

    Attributes
    ----------
    fit_info :
        A `scipy.optimize.OptimizeResult` class which contains all of
        the most recent fit information
    """
    def __init__(self, calc_uncertainties=..., use_min_max_bounds=...) -> None:
        ...
    


class DogBoxLSQFitter(_NLLSQFitter):
    """
    DogBox algorithm and least squares statistic.

    Parameters
    ----------
    calc_uncertainties : bool
        If the covarience matrix should be computed and set in the fit_info.
        Default: False
    use_min_max_bounds: bool
        If the set parameter bounds for a model will be enforced each given
        parameter while fitting via a simple min/max condition. A True setting
        will replicate how LevMarLSQFitter enforces bounds.
        Default: False

    Attributes
    ----------
    fit_info :
        A `scipy.optimize.OptimizeResult` class which contains all of
        the most recent fit information
    """
    def __init__(self, calc_uncertainties=..., use_min_max_bounds=...) -> None:
        ...
    


class LMLSQFitter(_NLLSQFitter):
    """
    `scipy.optimize.least_squares` Levenberg-Marquardt algorithm and least squares statistic.

    Parameters
    ----------
    calc_uncertainties : bool
        If the covarience matrix should be computed and set in the fit_info.
        Default: False

    Attributes
    ----------
    fit_info :
        A `scipy.optimize.OptimizeResult` class which contains all of
        the most recent fit information
    """
    def __init__(self, calc_uncertainties=...) -> None:
        ...
    


class SLSQPLSQFitter(Fitter):
    """
    Sequential Least Squares Programming (SLSQP) optimization algorithm and
    least squares statistic.

    Raises
    ------
    ModelLinearityError
        A linear model is passed to a nonlinear fitter

    Notes
    -----
    See also the `~astropy.modeling.optimizers.SLSQP` optimizer.

    """
    supported_constraints = ...
    def __init__(self) -> None:
        ...
    
    @fitter_unit_support
    def __call__(self, model, x, y, z=..., weights=..., **kwargs):
        """
        Fit data to this model.

        Parameters
        ----------
        model : `~astropy.modeling.FittableModel`
            model to fit to x, y, z
        x : array
            input coordinates
        y : array
            input coordinates
        z : array, optional
            input coordinates
        weights : array, optional
            Weights for fitting.
            For data with Gaussian uncertainties, the weights should be
            1/sigma.
        kwargs : dict
            optional keyword arguments to be passed to the optimizer or the statistic
        verblevel : int
            0-silent
            1-print summary upon completion,
            2-print summary after each iteration
        maxiter : int
            maximum number of iterations
        epsilon : float
            the step size for finite-difference derivative estimates
        acc : float
            Requested accuracy
        equivalencies : list or None, optional, keyword-only
            List of *additional* equivalencies that are should be applied in
            case x, y and/or z have units. Default is None.

        Returns
        -------
        model_copy : `~astropy.modeling.FittableModel`
            a copy of the input model with parameters set by the fitter

        """
        ...
    


class SimplexLSQFitter(Fitter):
    """
    Simplex algorithm and least squares statistic.

    Raises
    ------
    `ModelLinearityError`
        A linear model is passed to a nonlinear fitter

    """
    supported_constraints = ...
    def __init__(self) -> None:
        ...
    
    @fitter_unit_support
    def __call__(self, model, x, y, z=..., weights=..., **kwargs):
        """
        Fit data to this model.

        Parameters
        ----------
        model : `~astropy.modeling.FittableModel`
            model to fit to x, y, z
        x : array
            input coordinates
        y : array
            input coordinates
        z : array, optional
            input coordinates
        weights : array, optional
            Weights for fitting.
            For data with Gaussian uncertainties, the weights should be
            1/sigma.
        kwargs : dict
            optional keyword arguments to be passed to the optimizer or the statistic
        maxiter : int
            maximum number of iterations
        acc : float
            Relative error in approximate solution
        equivalencies : list or None, optional, keyword-only
            List of *additional* equivalencies that are should be applied in
            case x, y and/or z have units. Default is None.

        Returns
        -------
        model_copy : `~astropy.modeling.FittableModel`
            a copy of the input model with parameters set by the fitter

        """
        ...
    


class JointFitter(metaclass=_FitterMeta):
    """
    Fit models which share a parameter.
    For example, fit two gaussians to two data sets but keep
    the FWHM the same.

    Parameters
    ----------
    models : list
        a list of model instances
    jointparameters : list
        a list of joint parameters
    initvals : list
        a list of initial values

    """
    def __init__(self, models, jointparameters, initvals) -> None:
        ...
    
    def model_to_fit_params(self): # -> list[Unknown]:
        ...
    
    def objective_function(self, fps, *args): # -> NDArray[Unknown]:
        """
        Function to minimize.

        Parameters
        ----------
        fps : list
            the fitted parameters - result of an one iteration of the
            fitting algorithm
        args : dict
            tuple of measured and input coordinates
            args is always passed as a tuple from optimize.leastsq

        """
        ...
    
    def __call__(self, *args): # -> None:
        """
        Fit data to these models keeping some of the parameters common to the
        two models.
        """
        ...
    


def fitter_to_model_params(model, fps, use_min_max_bounds=...): # -> None:
    """
    Constructs the full list of model parameters from the fitted and
    constrained parameters.

    Parameters
    ----------
    model :
        The model being fit
    fps :
        The fit parameter values to be assigned
    use_min_max_bounds: bool
        If the set parameter bounds for model will be enforced on each
        parameter with bounds.
        Default: True
    """
    ...

def model_to_fit_params(model): # -> tuple[NDArray[Unknown] | Unknown, list[int], tuple[tuple[Unknown], ...]]:
    """
    Convert a model instance's parameter array to an array that can be used
    with a fitter that doesn't natively support fixed or tied parameters.
    In particular, it removes fixed/tied parameters from the parameter
    array.
    These may be a subset of the model parameters, if some of them are held
    constant or tied.
    """
    ...

def populate_entry_points(entry_points): # -> None:
    """
    This injects entry points into the `astropy.modeling.fitting` namespace.
    This provides a means of inserting a fitting routine without requirement
    of it being merged into astropy's core.

    Parameters
    ----------
    entry_points : list of `~importlib.metadata.EntryPoint`
        entry_points are objects which encapsulate importable objects and
        are defined on the installation of a package.

    Notes
    -----
    An explanation of entry points can be found `here
    <http://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins>`_
    """
    ...

