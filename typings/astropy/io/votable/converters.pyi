"""
This type stub file was generated by pyright.
"""

import sys

"""
This module handles the conversion of various VOTABLE datatypes
to/from TABLEDATA_ and BINARY_ formats.
"""
__all__ = ['get_converter', 'Converter', 'table_column_to_votable_datatype']
pedantic_array_splitter = ...
array_splitter = ...
_zero_int = ...
_empty_bytes = ...
_zero_byte = ...
struct_unpack = ...
struct_pack = ...
if sys.byteorder == 'little':
    ...
else:
    ...
def bitarray_to_bool(data, length): # -> NDArray[Any]:
    """
    Converts a bit array (a string of bits in a bytes object) to a
    boolean Numpy array.

    Parameters
    ----------
    data : bytes
        The bit array.  The most significant byte is read first.

    length : int
        The number of bits to read.  The least significant bits in the
        data bytes beyond length will be ignored.

    Returns
    -------
    array : numpy bool array
    """
    ...

def bool_to_bitarray(value): # -> bytes:
    """
    Converts a numpy boolean array to a bit array (a string of bits in
    a bytes object).

    Parameters
    ----------
    value : numpy bool array

    Returns
    -------
    bit_array : bytes
        The first value in the input array will be the most
        significant bit in the result.  The length will be `floor((N +
        7) / 8)` where `N` is the length of `value`.
    """
    ...

class Converter:
    """
    The base class for all converters.  Each subclass handles
    converting a specific VOTABLE data type to/from the TABLEDATA_ and
    BINARY_ on-disk representations.

    Parameters
    ----------
    field : `~astropy.io.votable.tree.Field`
        object describing the datatype

    config : dict
        The parser configuration dictionary

    pos : tuple
        The position in the XML file where the FIELD object was
        found.  Used for error messages.

    """
    def __init__(self, field, config=..., pos=...) -> None:
        ...
    
    def supports_empty_values(self, config):
        """
        Returns True when the field can be completely empty.
        """
        ...
    
    def parse(self, value, config=..., pos=...):
        """
        Convert the string *value* from the TABLEDATA_ format into an
        object with the correct native in-memory datatype and mask flag.

        Parameters
        ----------
        value : str
            value in TABLEDATA format

        Returns
        -------
        native : tuple
            A two-element tuple of: value, mask.
            The value as a Numpy array or scalar, and *mask* is True
            if the value is missing.
        """
        ...
    
    def parse_scalar(self, value, config=..., pos=...):
        """
        Parse a single scalar of the underlying type of the converter.
        For non-array converters, this is equivalent to parse.  For
        array converters, this is used to parse a single
        element of the array.

        Parameters
        ----------
        value : str
            value in TABLEDATA format

        Returns
        -------
        native : (2,) tuple
            (value, mask)
            The value as a Numpy array or scalar, and *mask* is True
            if the value is missing.
        """
        ...
    
    def output(self, value, mask):
        """
        Convert the object *value* (in the native in-memory datatype)
        to a unicode string suitable for serializing in the TABLEDATA_
        format.

        Parameters
        ----------
        value
            The value, the native type corresponding to this converter

        mask : bool
            If `True`, will return the string representation of a
            masked value.

        Returns
        -------
        tabledata_repr : unicode
        """
        ...
    
    def binparse(self, read):
        """
        Reads some number of bytes from the BINARY_ format
        representation by calling the function *read*, and returns the
        native in-memory object representation for the datatype
        handled by *self*.

        Parameters
        ----------
        read : function
            A function that given a number of bytes, returns a byte
            string.

        Returns
        -------
        native : (2,) tuple
            (value, mask). The value as a Numpy array or scalar, and *mask* is
            True if the value is missing.
        """
        ...
    
    def binoutput(self, value, mask):
        """
        Convert the object *value* in the native in-memory datatype to
        a string of bytes suitable for serialization in the BINARY_
        format.

        Parameters
        ----------
        value
            The value, the native type corresponding to this converter

        mask : bool
            If `True`, will return the string representation of a
            masked value.

        Returns
        -------
        bytes : bytes
            The binary representation of the value, suitable for
            serialization in the BINARY_ format.
        """
        ...
    


class Char(Converter):
    """
    Handles the char datatype. (7-bit unsigned characters)

    Missing values are not handled for string or unicode types.
    """
    default = ...
    def __init__(self, field, config=..., pos=...) -> None:
        ...
    
    def supports_empty_values(self, config): # -> Literal[True]:
        ...
    
    def parse(self, value, config=..., pos=...): # -> tuple[Unknown, Literal[False]]:
        ...
    
    def output(self, value, mask): # -> str:
        ...
    


class UnicodeChar(Converter):
    """
    Handles the unicodeChar data type. UTF-16-BE.

    Missing values are not handled for string or unicode types.
    """
    default = ...
    def __init__(self, field, config=..., pos=...) -> None:
        ...
    
    def parse(self, value, config=..., pos=...): # -> tuple[Unknown, Literal[False]]:
        ...
    
    def output(self, value, mask): # -> str:
        ...
    


class Array(Converter):
    """
    Handles both fixed and variable-lengths arrays.
    """
    def __init__(self, field, config=..., pos=...) -> None:
        ...
    
    def parse_scalar(self, value, config=..., pos=...):
        ...
    


class VarArray(Array):
    """
    Handles variable lengths arrays (i.e. where *arraysize* is '*').
    """
    format = ...
    def __init__(self, field, base, arraysize, config=..., pos=...) -> None:
        ...
    
    def output(self, value, mask): # -> LiteralString:
        ...
    
    def binparse(self, read): # -> tuple[Unknown, Literal[False]]:
        ...
    
    def binoutput(self, value, mask): # -> bytes:
        ...
    


class ArrayVarArray(VarArray):
    """
    Handles an array of variable-length arrays, i.e. where *arraysize*
    ends in '*'.
    """
    def parse(self, value, config=..., pos=...): # -> tuple[Unknown, Literal[False]]:
        ...
    


class ScalarVarArray(VarArray):
    """
    Handles a variable-length array of numeric scalars.
    """
    def parse(self, value, config=..., pos=...): # -> tuple[Unknown, Literal[False]]:
        ...
    


class NumericArray(Array):
    """
    Handles a fixed-length array of numeric scalars.
    """
    vararray_type = ArrayVarArray
    def __init__(self, field, base, arraysize, config=..., pos=...) -> None:
        ...
    
    def parse(self, value, config=..., pos=...): # -> tuple[NDArray[float64], Literal[True]] | tuple[ndarray[Any, dtype[Unknown]], ndarray[Any, dtype[Any]]]:
        ...
    
    def parse_parts(self, parts, config=..., pos=...): # -> tuple[ndarray[Any, dtype[Unknown]], ndarray[Any, dtype[Any]]]:
        ...
    
    def output(self, value, mask): # -> LiteralString:
        ...
    
    def binparse(self, read): # -> tuple[Any, Unknown]:
        ...
    
    def binoutput(self, value, mask):
        ...
    


class Numeric(Converter):
    """
    The base class for all numeric data types.
    """
    array_type = NumericArray
    vararray_type = ScalarVarArray
    null = ...
    def __init__(self, field, config=..., pos=...) -> None:
        ...
    
    def binparse(self, read): # -> tuple[Any, Any]:
        ...
    


class FloatingPoint(Numeric):
    """
    The base class for floating-point datatypes.
    """
    default = ...
    def __init__(self, field, config=..., pos=...) -> None:
        ...
    
    def supports_empty_values(self, config): # -> Literal[True]:
        ...
    
    @property
    def output_format(self): # -> str:
        ...
    
    def output(self, value, mask): # -> str:
        ...
    
    def binoutput(self, value, mask):
        ...
    


class Double(FloatingPoint):
    """
    Handles the double datatype.  Double-precision IEEE
    floating-point.
    """
    format = ...


class Float(FloatingPoint):
    """
    Handles the float datatype.  Single-precision IEEE floating-point.
    """
    format = ...


class Integer(Numeric):
    """
    The base class for all the integral datatypes.
    """
    default = ...
    def __init__(self, field, config=..., pos=...) -> None:
        ...
    
    def parse(self, value, config=..., pos=...): # -> tuple[Unknown | NDArray[Unknown] | int, bool]:
        ...
    
    def output(self, value, mask): # -> str:
        ...
    
    def binoutput(self, value, mask): # -> bytes:
        ...
    
    def filter_array(self, value, mask): # -> NDArray[Any]:
        ...
    


class UnsignedByte(Integer):
    """
    Handles the unsignedByte datatype.  Unsigned 8-bit integer.
    """
    format = ...
    val_range = ...
    bit_size = ...


class Short(Integer):
    """
    Handles the short datatype.  Signed 16-bit integer.
    """
    format = ...
    val_range = ...
    bit_size = ...


class Int(Integer):
    """
    Handles the int datatype.  Signed 32-bit integer.
    """
    format = ...
    val_range = ...
    bit_size = ...


class Long(Integer):
    """
    Handles the long datatype.  Signed 64-bit integer.
    """
    format = ...
    val_range = ...
    bit_size = ...


class ComplexArrayVarArray(VarArray):
    """
    Handles an array of variable-length arrays of complex numbers.
    """
    def parse(self, value, config=..., pos=...): # -> tuple[Unknown, Literal[True]] | tuple[Unknown, Literal[False]]:
        ...
    


class ComplexVarArray(VarArray):
    """
    Handles a variable-length array of complex numbers.
    """
    def parse(self, value, config=..., pos=...): # -> tuple[Unknown, Literal[True]] | tuple[Unknown, Literal[False]]:
        ...
    


class ComplexArray(NumericArray):
    """
    Handles a fixed-size array of complex numbers.
    """
    vararray_type = ComplexArrayVarArray
    def __init__(self, field, base, arraysize, config=..., pos=...) -> None:
        ...
    
    def parse(self, value, config=..., pos=...): # -> tuple[ndarray[Any, dtype[Unknown]], ndarray[Any, dtype[Any]]]:
        ...
    
    def parse_parts(self, parts, config=..., pos=...): # -> tuple[ndarray[Any, dtype[Unknown]], ndarray[Any, dtype[Any]]]:
        ...
    


class Complex(FloatingPoint, Array):
    """
    The base class for complex numbers.
    """
    array_type = ComplexArray
    vararray_type = ComplexVarArray
    default = ...
    def __init__(self, field, config=..., pos=...) -> None:
        ...
    
    def parse(self, value, config=..., pos=...): # -> tuple[float, Literal[True]] | tuple[complex, bool | Any]:
        ...
    
    _parse_permissive = ...
    _parse_pedantic = ...
    def parse_parts(self, parts, config=..., pos=...): # -> tuple[complex, bool | Any]:
        ...
    
    def output(self, value, mask): # -> str:
        ...
    


class FloatComplex(Complex):
    """
    Handle floatComplex datatype.  Pair of single-precision IEEE
    floating-point numbers.
    """
    format = ...


class DoubleComplex(Complex):
    """
    Handle doubleComplex datatype.  Pair of double-precision IEEE
    floating-point numbers.
    """
    format = ...


class BitArray(NumericArray):
    """
    Handles an array of bits.
    """
    vararray_type = ArrayVarArray
    def __init__(self, field, base, arraysize, config=..., pos=...) -> None:
        ...
    
    def output(self, value, mask): # -> str:
        ...
    
    def binparse(self, read): # -> tuple[ndarray[Any, dtype[Any]], NDArray[Any]]:
        ...
    
    def binoutput(self, value, mask): # -> bytes:
        ...
    


class Bit(Converter):
    """
    Handles the bit datatype.
    """
    format = ...
    array_type = BitArray
    vararray_type = ScalarVarArray
    default = ...
    binary_one = ...
    binary_zero = ...
    def parse(self, value, config=..., pos=...): # -> tuple[Literal[False], Literal[True]] | tuple[bool, Literal[False]]:
        ...
    
    def output(self, value, mask): # -> Literal['1', '0']:
        ...
    
    def binparse(self, read): # -> tuple[bool, Literal[False]]:
        ...
    
    def binoutput(self, value, mask): # -> bytes:
        ...
    


class BooleanArray(NumericArray):
    """
    Handles an array of boolean values.
    """
    vararray_type = ArrayVarArray
    def binparse(self, read): # -> tuple[ndarray[Any, dtype[Any]], ndarray[Any, dtype[Any]]]:
        ...
    
    def binoutput(self, value, mask): # -> bytes:
        ...
    


class Boolean(Converter):
    """
    Handles the boolean datatype.
    """
    format = ...
    array_type = BooleanArray
    vararray_type = ScalarVarArray
    default = ...
    binary_question_mark = ...
    binary_true = ...
    binary_false = ...
    def parse(self, value, config=..., pos=...): # -> tuple[Literal[False], Literal[True]] | tuple[Literal[True], Literal[False]] | tuple[Literal[False], Literal[False]]:
        ...
    
    def output(self, value, mask): # -> Literal['?', 'T', 'F']:
        ...
    
    def binparse(self, read): # -> tuple[Literal[True], Literal[False]] | tuple[Literal[False], Literal[False]] | tuple[Literal[False], Literal[True]]:
        ...
    
    _binparse_mapping = ...
    def binparse_value(self, value): # -> tuple[Literal[True], Literal[False]] | tuple[Literal[False], Literal[False]] | tuple[Literal[False], Literal[True]]:
        ...
    
    def binoutput(self, value, mask): # -> bytes:
        ...
    


converter_mapping = ...
def get_converter(field, config=..., pos=...): # -> vararray_type | array_type | Double | Float | Bit | Boolean | UnsignedByte | Short | Int | Long | FloatComplex | DoubleComplex | Char | UnicodeChar:
    """
    Get an appropriate converter instance for a given field.

    Parameters
    ----------
    field : astropy.io.votable.tree.Field

    config : dict, optional
        Parser configuration dictionary

    pos : tuple
        Position in the input XML file.  Used for error messages.

    Returns
    -------
    converter : astropy.io.votable.converters.Converter
    """
    ...

numpy_dtype_to_field_mapping = ...
def numpy_to_votable_dtype(dtype, shape): # -> dict[str, str]:
    """
    Converts a numpy dtype and shape to a dictionary of attributes for
    a VOTable FIELD element and correspond to that type.

    Parameters
    ----------
    dtype : Numpy dtype instance

    shape : tuple

    Returns
    -------
    attributes : dict
        A dict containing 'datatype' and 'arraysize' keys that can be
        set on a VOTable FIELD element.
    """
    ...

def table_column_to_votable_datatype(column): # -> dict[str, Unknown | str] | dict[str, str]:
    """
    Given a `astropy.table.Column` instance, returns the attributes
    necessary to create a VOTable FIELD element that corresponds to
    the type of the column.

    This necessarily must perform some heuristics to determine the
    type of variable length arrays fields, since they are not directly
    supported by Numpy.

    If the column has dtype of "object", it performs the following
    tests:

       - If all elements are byte or unicode strings, it creates a
         variable-length byte or unicode field, respectively.

       - If all elements are numpy arrays of the same dtype and with a
         consistent shape in all but the first dimension, it creates a
         variable length array of fixed sized arrays.  If the dtypes
         match, but the shapes do not, a variable length array is
         created.

    If the dtype of the input is not understood, it sets the data type
    to the most inclusive: a variable length unicodeChar array.

    Parameters
    ----------
    column : `astropy.table.Column` instance

    Returns
    -------
    attributes : dict
        A dict containing 'datatype' and 'arraysize' keys that can be
        set on a VOTable FIELD element.
    """
    ...

