"""
This type stub file was generated by pyright.
"""

from astropy.utils.exceptions import AstropyWarning

"""
This module contains helper functions and classes for handling metadata.
"""
__all__ = ['MergeConflictError', 'MergeConflictWarning', 'MERGE_STRATEGIES', 'common_dtype', 'MergePlus', 'MergeNpConcatenate', 'MergeStrategy', 'MergeStrategyMeta', 'enable_merge_strategies', 'merge', 'MetaData', 'MetaAttribute']
class MergeConflictError(TypeError):
    ...


class MergeConflictWarning(AstropyWarning):
    ...


MERGE_STRATEGIES = ...
def common_dtype(arrs): # -> str | list[tuple[str, str] | tuple[str, str, _Shape]]:
    """
    Use numpy to find the common dtype for a list of ndarrays.

    Only allow arrays within the following fundamental numpy data types:
    ``np.bool_``, ``np.object_``, ``np.number``, ``np.character``, ``np.void``

    Parameters
    ----------
    arrs : list of ndarray
        Arrays for which to find the common dtype

    Returns
    -------
    dtype_str : str
        String representation of dytpe (dtype ``str`` attribute)
    """
    ...

class MergeStrategyMeta(type):
    """
    Metaclass that registers MergeStrategy subclasses into the
    MERGE_STRATEGIES registry.
    """
    def __new__(mcls, name, bases, members): # -> Self@MergeStrategyMeta:
        ...
    


class MergeStrategy(metaclass=MergeStrategyMeta):
    """
    Base class for defining a strategy for merging metadata from two
    sources, left and right, into a single output.

    The primary functionality for the class is the ``merge(cls, left, right)``
    class method.  This takes ``left`` and ``right`` side arguments and
    returns a single merged output.

    The first class attribute is ``types``.  This is defined as a list of
    (left_types, right_types) tuples that indicate for which input types the
    merge strategy applies.  In determining whether to apply this merge
    strategy to a pair of (left, right) objects, a test is done:
    ``isinstance(left, left_types) and isinstance(right, right_types)``.  For
    example::

      types = [(np.ndarray, np.ndarray),  # Two ndarrays
               (np.ndarray, (list, tuple)),  # ndarray and (list or tuple)
               ((list, tuple), np.ndarray)]  # (list or tuple) and ndarray

    As a convenience, ``types`` can be defined as a single two-tuple instead of
    a list of two-tuples, e.g. ``types = (np.ndarray, np.ndarray)``.

    The other class attribute is ``enabled``, which defaults to ``False`` in
    the base class.  By defining a subclass of ``MergeStrategy`` the new merge
    strategy is automatically registered to be available for use in
    merging. However, by default the new merge strategy is *not enabled*.  This
    prevents inadvertently changing the behavior of unrelated code that is
    performing metadata merge operations.

    In most cases (particularly in library code that others might use) it is
    recommended to leave custom strategies disabled and use the
    `~astropy.utils.metadata.enable_merge_strategies` context manager to locally
    enable the desired strategies.  However, if one is confident that the
    new strategy will not produce unexpected behavior, then one can globally
    enable it by setting the ``enabled`` class attribute to ``True``.

    Examples
    --------
    Here we define a custom merge strategy that takes an int or float on
    the left and right sides and returns a list with the two values.

      >>> from astropy.utils.metadata import MergeStrategy
      >>> class MergeNumbersAsList(MergeStrategy):
      ...     types = ((int, float), (int, float))  # (left_types, right_types)
      ...
      ...     @classmethod
      ...     def merge(cls, left, right):
      ...         return [left, right]

    """
    enabled = ...


class MergePlus(MergeStrategy):
    """
    Merge ``left`` and ``right`` objects using the plus operator.  This
    merge strategy is globally enabled by default.
    """
    types = ...
    enabled = ...
    @classmethod
    def merge(cls, left, right):
        ...
    


class MergeNpConcatenate(MergeStrategy):
    """
    Merge ``left`` and ``right`` objects using np.concatenate.  This
    merge strategy is globally enabled by default.

    This will upcast a list or tuple to np.ndarray and the output is
    always ndarray.
    """
    types = ...
    enabled = ...
    @classmethod
    def merge(cls, left, right): # -> NDArray[Unknown]:
        ...
    


class _EnableMergeStrategies:
    def __init__(self, *merge_strategies) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, type, value, tb): # -> None:
        ...
    


def enable_merge_strategies(*merge_strategies): # -> _EnableMergeStrategies:
    """
    Context manager to temporarily enable one or more custom metadata merge
    strategies.

    Examples
    --------
    Here we define a custom merge strategy that takes an int or float on
    the left and right sides and returns a list with the two values.

      >>> from astropy.utils.metadata import MergeStrategy
      >>> class MergeNumbersAsList(MergeStrategy):
      ...     types = ((int, float),  # left side types
      ...              (int, float))  # right side types
      ...     @classmethod
      ...     def merge(cls, left, right):
      ...         return [left, right]

    By defining this class the merge strategy is automatically registered to be
    available for use in merging. However, by default new merge strategies are
    *not enabled*.  This prevents inadvertently changing the behavior of
    unrelated code that is performing metadata merge operations.

    In order to use the new merge strategy, use this context manager as in the
    following example::

      >>> from astropy.table import Table, vstack
      >>> from astropy.utils.metadata import enable_merge_strategies
      >>> t1 = Table([[1]], names=['a'])
      >>> t2 = Table([[2]], names=['a'])
      >>> t1.meta = {'m': 1}
      >>> t2.meta = {'m': 2}
      >>> with enable_merge_strategies(MergeNumbersAsList):
      ...    t12 = vstack([t1, t2])
      >>> t12.meta['m']
      [1, 2]

    One can supply further merge strategies as additional arguments to the
    context manager.

    As a convenience, the enabling operation is actually done by checking
    whether the registered strategies are subclasses of the context manager
    arguments.  This means one can define a related set of merge strategies and
    then enable them all at once by enabling the base class.  As a trivial
    example, *all* registered merge strategies can be enabled with::

      >>> with enable_merge_strategies(MergeStrategy):
      ...    t12 = vstack([t1, t2])

    Parameters
    ----------
    *merge_strategies : `~astropy.utils.metadata.MergeStrategy`
        Merge strategies that will be enabled.

    """
    ...

def merge(left, right, merge_func=..., metadata_conflicts=..., warn_str_func=..., error_str_func=...):
    """
    Merge the ``left`` and ``right`` metadata objects.

    This is a simplistic and limited implementation at this point.
    """
    ...

class MetaData:
    """
    A descriptor for classes that have a ``meta`` property.

    This can be set to any valid `~collections.abc.Mapping`.

    Parameters
    ----------
    doc : `str`, optional
        Documentation for the attribute of the class.
        Default is ``""``.

        .. versionadded:: 1.2

    copy : `bool`, optional
        If ``True`` the the value is deepcopied before setting, otherwise it
        is saved as reference.
        Default is ``True``.

        .. versionadded:: 1.2
    """
    def __init__(self, doc=..., copy=...) -> None:
        ...
    
    def __get__(self, instance, owner): # -> Self@MetaData | OrderedDict[Unknown, Unknown]:
        ...
    
    def __set__(self, instance, value): # -> None:
        ...
    


class MetaAttribute:
    """
    Descriptor to define custom attribute which gets stored in the object
    ``meta`` dict and can have a defined default.

    This descriptor is intended to provide a convenient way to add attributes
    to a subclass of a complex class such as ``Table`` or ``NDData``.

    This requires that the object has an attribute ``meta`` which is a
    dict-like object.  The value of the MetaAttribute will be stored in a
    new dict meta['__attributes__'] that is created when required.

    Classes that define MetaAttributes are encouraged to support initializing
    the attributes via the class ``__init__``.  For example::

        for attr in list(kwargs):
            descr = getattr(self.__class__, attr, None)
            if isinstance(descr, MetaAttribute):
                setattr(self, attr, kwargs.pop(attr))

    The name of a ``MetaAttribute`` cannot be the same as any of the following:

    - Keyword argument in the owner class ``__init__``
    - Method or attribute of the "parent class", where the parent class is
      taken to be ``owner.__mro__[1]``.

    :param default: default value

    """
    def __init__(self, default=...) -> None:
        ...
    
    def __get__(self, instance, owner): # -> Self@MetaAttribute | None:
        ...
    
    def __set__(self, instance, value): # -> None:
        ...
    
    def __delete__(self, instance): # -> None:
        ...
    
    def __set_name__(self, owner, name): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    


