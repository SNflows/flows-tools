"""
This type stub file was generated by pyright.
"""

"""Time utilities.

In particular, routines to do basic arithmetic on numbers represented by two
doubles, using the procedure of Shewchuk, 1997, Discrete & Computational
Geometry 18(3):305-363 -- http://www.cs.berkeley.edu/~jrs/papers/robustr.pdf

Furthermore, some helper routines to turn strings and other types of
objects into two values, and vice versa.
"""
def day_frac(val1, val2, factor=..., divisor=...): # -> tuple[NDArray[floating[Any]], Unknown]:
    """Return the sum of ``val1`` and ``val2`` as two float64s.

    The returned floats are an integer part and the fractional remainder,
    with the latter guaranteed to be within -0.5 and 0.5 (inclusive on
    either side, as the integer is rounded to even).

    The arithmetic is all done with exact floating point operations so no
    precision is lost to rounding error.  It is assumed the sum is less
    than about 1e16, otherwise the remainder will be greater than 1.0.

    Parameters
    ----------
    val1, val2 : array of float
        Values to be summed.
    factor : float, optional
        If given, multiply the sum by it.
    divisor : float, optional
        If given, divide the sum by it.

    Returns
    -------
    day, frac : float64
        Integer and fractional part of val1 + val2.
    """
    ...

def quantity_day_frac(val1, val2=...): # -> tuple[Unknown, Unknown] | tuple[Unknown, float] | tuple[NDArray[floating[Any]], Unknown]:
    """Like ``day_frac``, but for quantities with units of time.

    The quantities are separately converted to days. Here, we need to take
    care with the conversion since while the routines here can do accurate
    multiplication, the conversion factor itself may not be accurate.  For
    instance, if the quantity is in seconds, the conversion factor is
    1./86400., which is not exactly representable as a float.

    To work around this, for conversion factors less than unity, rather than
    multiply by that possibly inaccurate factor, the value is divided by the
    conversion factor of a day to that unit (i.e., by 86400. for seconds).  For
    conversion factors larger than 1, such as 365.25 for years, we do just
    multiply.  With this scheme, one has precise conversion factors for all
    regular time units that astropy defines.  Note, however, that it does not
    necessarily work for all custom time units, and cannot work when conversion
    to time is via an equivalency.  For those cases, one remains limited by the
    fact that Quantity calculations are done in double precision, not in
    quadruple precision as for time.
    """
    ...

def two_sum(a, b): # -> tuple[Unknown, Unknown]:
    """
    Add ``a`` and ``b`` exactly, returning the result as two float64s.
    The first is the approximate sum (with some floating point error)
    and the second is the error of the float64 sum.

    Using the procedure of Shewchuk, 1997,
    Discrete & Computational Geometry 18(3):305-363
    http://www.cs.berkeley.edu/~jrs/papers/robustr.pdf

    Returns
    -------
    sum, err : float64
        Approximate sum of a + b and the exact floating point error
    """
    ...

def two_product(a, b): # -> tuple[Unknown, Unknown]:
    """
    Multiple ``a`` and ``b`` exactly, returning the result as two float64s.
    The first is the approximate product (with some floating point error)
    and the second is the error of the float64 product.

    Uses the procedure of Shewchuk, 1997,
    Discrete & Computational Geometry 18(3):305-363
    http://www.cs.berkeley.edu/~jrs/papers/robustr.pdf

    Returns
    -------
    prod, err : float64
        Approximate product a * b and the exact floating point error
    """
    ...

def split(a): # -> tuple[Unknown, Unknown]:
    """
    Split float64 in two aligned parts.

    Uses the procedure of Shewchuk, 1997,
    Discrete & Computational Geometry 18(3):305-363
    http://www.cs.berkeley.edu/~jrs/papers/robustr.pdf

    """
    ...

_enough_decimal_places = ...
def longdouble_to_twoval(val1, val2=...): # -> tuple[NDArray[Any], Unknown]:
    ...

def decimal_to_twoval1(val1, val2=...): # -> tuple[float, float]:
    ...

def bytes_to_twoval1(val1, val2=...): # -> tuple[float, float]:
    ...

def twoval_to_longdouble(val1, val2):
    ...

def twoval_to_decimal1(val1, val2): # -> Decimal:
    ...

def twoval_to_string1(val1, val2, fmt): # -> str:
    ...

def twoval_to_bytes1(val1, val2, fmt): # -> bytes:
    ...

decimal_to_twoval = ...
bytes_to_twoval = ...
twoval_to_decimal = ...
twoval_to_string = ...
twoval_to_bytes = ...
