"""
This type stub file was generated by pyright.
"""

import sys

__version__ = ...
__tabversion__ = ...
yaccdebug = ...
debug_file = ...
tab_module = ...
default_lr = ...
error_count = ...
yaccdevel = ...
resultlimit = ...
pickle_protocol = ...
if sys.version_info[0] < 3:
    ...
else:
    string_types = str
MAXINT = ...
class PlyLogger:
    def __init__(self, f) -> None:
        ...
    
    def debug(self, msg, *args, **kwargs): # -> None:
        ...
    
    info = ...
    def warning(self, msg, *args, **kwargs): # -> None:
        ...
    
    def error(self, msg, *args, **kwargs): # -> None:
        ...
    
    critical = ...


class NullLogger:
    def __getattribute__(self, name): # -> Self@NullLogger:
        ...
    
    def __call__(self, *args, **kwargs): # -> Self@NullLogger:
        ...
    


class YaccError(Exception):
    ...


def format_result(r): # -> str:
    ...

def format_stack_entry(r): # -> str:
    ...

_errok = ...
_token = ...
_restart = ...
_warnmsg = ...
def errok():
    ...

def restart():
    ...

def token():
    ...

def call_errorfunc(errorfunc, token, parser):
    ...

class YaccSymbol:
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class YaccProduction:
    def __init__(self, s, stack=...) -> None:
        ...
    
    def __getitem__(self, n): # -> list[Unknown]:
        ...
    
    def __setitem__(self, n, v): # -> None:
        ...
    
    def __getslice__(self, i, j): # -> list[Unknown]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def lineno(self, n): # -> Any | int:
        ...
    
    def set_lineno(self, n, lineno): # -> None:
        ...
    
    def linespan(self, n): # -> tuple[Any | int, Any | int]:
        ...
    
    def lexpos(self, n): # -> Any | int:
        ...
    
    def set_lexpos(self, n, lexpos): # -> None:
        ...
    
    def lexspan(self, n): # -> tuple[Any | int, Any | int]:
        ...
    
    def error(self):
        ...
    


class LRParser:
    def __init__(self, lrtab, errorf) -> None:
        ...
    
    def errok(self): # -> None:
        ...
    
    def restart(self): # -> None:
        ...
    
    def set_defaulted_states(self): # -> None:
        ...
    
    def disable_defaulted_states(self): # -> None:
        ...
    
    def parse(self, input=..., lexer=..., debug=..., tracking=..., tokenfunc=...):
        ...
    
    def parsedebug(self, input=..., lexer=..., debug=..., tracking=..., tokenfunc=...):
        ...
    
    def parseopt(self, input=..., lexer=..., debug=..., tracking=..., tokenfunc=...):
        ...
    
    def parseopt_notrack(self, input=..., lexer=..., debug=..., tracking=..., tokenfunc=...):
        ...
    


_is_identifier = ...
class Production:
    reduced = ...
    def __init__(self, number, name, prod, precedence=..., func=..., file=..., line=...) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __nonzero__(self): # -> Literal[1]:
        ...
    
    def __getitem__(self, index):
        ...
    
    def lr_item(self, n): # -> LRItem | None:
        ...
    
    def bind(self, pdict): # -> None:
        ...
    


class MiniProduction:
    def __init__(self, str, name, len, func, file, line) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def bind(self, pdict): # -> None:
        ...
    


class LRItem:
    def __init__(self, p, n) -> None:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


def rightmost_terminal(symbols, terminals): # -> None:
    ...

class GrammarError(YaccError):
    ...


class Grammar:
    def __init__(self, terminals) -> None:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, index): # -> None:
        ...
    
    def set_precedence(self, term, assoc, level): # -> None:
        ...
    
    def add_production(self, prodname, syms, func=..., file=..., line=...): # -> None:
        ...
    
    def set_start(self, start=...): # -> None:
        ...
    
    def find_unreachable(self): # -> list[Unknown]:
        ...
    
    def infinite_cycles(self): # -> list[Unknown]:
        ...
    
    def undefined_symbols(self): # -> list[Unknown]:
        ...
    
    def unused_terminals(self): # -> list[Unknown]:
        ...
    
    def unused_rules(self): # -> list[Unknown]:
        ...
    
    def unused_precedence(self): # -> list[Unknown]:
        ...
    
    def compute_first(self): # -> dict[Unknown, Unknown]:
        ...
    
    def compute_follow(self, start=...): # -> dict[Unknown, Unknown]:
        ...
    
    def build_lritems(self): # -> None:
        ...
    


class VersionError(YaccError):
    ...


class LRTable:
    def __init__(self) -> None:
        ...
    
    def read_table(self, module): # -> Any:
        ...
    
    def read_pickle(self, filename): # -> Any:
        ...
    
    def bind_callables(self, pdict): # -> None:
        ...
    


def digraph(X, R, FP): # -> dict[Unknown, Unknown]:
    ...

def traverse(x, N, stack, F, X, R, FP): # -> None:
    ...

class LALRError(YaccError):
    ...


class LRGeneratedTable(LRTable):
    def __init__(self, grammar, method=..., log=...) -> None:
        ...
    
    def lr0_closure(self, I):
        ...
    
    def lr0_goto(self, I, x): # -> list[Unknown] | None:
        ...
    
    def lr0_items(self): # -> list[list[Unknown]]:
        ...
    
    def compute_nullable_nonterminals(self): # -> set[Unknown]:
        ...
    
    def find_nonterminal_transitions(self, C): # -> list[Unknown]:
        ...
    
    def dr_relation(self, C, trans, nullable): # -> list[Unknown]:
        ...
    
    def reads_relation(self, C, trans, empty): # -> list[Unknown]:
        ...
    
    def compute_lookback_includes(self, C, trans, nullable): # -> tuple[dict[Unknown, Unknown], dict[Unknown, Unknown]]:
        ...
    
    def compute_read_sets(self, C, ntrans, nullable): # -> dict[Unknown, Unknown]:
        ...
    
    def compute_follow_sets(self, ntrans, readsets, inclsets): # -> dict[Unknown, Unknown]:
        ...
    
    def add_lookaheads(self, lookbacks, followset): # -> None:
        ...
    
    def add_lalr_lookaheads(self, C): # -> None:
        ...
    
    def lr_parse_table(self): # -> None:
        ...
    
    def write_table(self, tabmodule, outputdir=..., signature=...):
        ...
    
    def pickle_table(self, filename, signature=...): # -> None:
        ...
    


def get_caller_module_dict(levels): # -> dict[str, Any]:
    ...

def parse_grammar(doc, file, line): # -> list[Unknown]:
    ...

class ParserReflect:
    def __init__(self, pdict, log=...) -> None:
        ...
    
    def get_all(self): # -> None:
        ...
    
    def validate_all(self): # -> bool:
        ...
    
    def signature(self): # -> LiteralString:
        ...
    
    def validate_modules(self): # -> None:
        ...
    
    def get_start(self): # -> None:
        ...
    
    def validate_start(self): # -> None:
        ...
    
    def get_error_func(self): # -> None:
        ...
    
    def validate_error_func(self): # -> None:
        ...
    
    def get_tokens(self): # -> None:
        ...
    
    def validate_tokens(self): # -> None:
        ...
    
    def get_precedence(self): # -> None:
        ...
    
    def validate_precedence(self): # -> None:
        ...
    
    def get_pfunctions(self): # -> None:
        ...
    
    def validate_pfunctions(self): # -> None:
        ...
    


def yacc(method=..., debug=..., module=..., tabmodule=..., start=..., check_recursion=..., optimize=..., write_tables=..., debugfile=..., outputdir=..., debuglog=..., errorlog=..., picklefile=...):
    ...

