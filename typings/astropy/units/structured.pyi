"""
This type stub file was generated by pyright.
"""

import numpy as np

"""
This module defines structured units and quantities.
"""
__all__ = ['StructuredUnit']
DTYPE_OBJECT = ...
class StructuredUnit:
    """Container for units for a structured Quantity.

    Parameters
    ----------
    units : unit-like, tuple of unit-like, or `~astropy.units.StructuredUnit`
        Tuples can be nested.  If a `~astropy.units.StructuredUnit` is passed
        in, it will be returned unchanged unless different names are requested.
    names : tuple of str, tuple or list; `~numpy.dtype`; or `~astropy.units.StructuredUnit`, optional
        Field names for the units, possibly nested. Can be inferred from a
        structured `~numpy.dtype` or another `~astropy.units.StructuredUnit`.
        For nested tuples, by default the name of the upper entry will be the
        concatenation of the names of the lower levels.  One can pass in a
        list with the upper-level name and a tuple of lower-level names to
        avoid this.  For tuples, not all levels have to be given; for any level
        not passed in, default field names of 'f0', 'f1', etc., will be used.

    Notes
    -----
    It is recommended to initialze the class indirectly, using
    `~astropy.units.Unit`.  E.g., ``u.Unit('AU,AU/day')``.

    When combined with a structured array to produce a structured
    `~astropy.units.Quantity`, array field names will take precedence.
    Generally, passing in ``names`` is needed only if the unit is used
    unattached to a `~astropy.units.Quantity` and one needs to access its
    fields.

    Examples
    --------
    Various ways to initialize a `~astropy.units.StructuredUnit`::

        >>> import astropy.units as u
        >>> su = u.Unit('(AU,AU/day),yr')
        >>> su
        Unit("((AU, AU / d), yr)")
        >>> su.field_names
        (['f0', ('f0', 'f1')], 'f1')
        >>> su['f1']
        Unit("yr")
        >>> su2 = u.StructuredUnit(((u.AU, u.AU/u.day), u.yr), names=(('p', 'v'), 't'))
        >>> su2 == su
        True
        >>> su2.field_names
        (['pv', ('p', 'v')], 't')
        >>> su3 = u.StructuredUnit((su2['pv'], u.day), names=(['p_v', ('p', 'v')], 't'))
        >>> su3.field_names
        (['p_v', ('p', 'v')], 't')
        >>> su3.keys()
        ('p_v', 't')
        >>> su3.values()
        (Unit("(AU, AU / d)"), Unit("d"))

    Structured units share most methods with regular units::

        >>> su.physical_type
        ((PhysicalType('length'), PhysicalType({'speed', 'velocity'})), PhysicalType('time'))
        >>> su.si
        Unit("((1.49598e+11 m, 1.73146e+06 m / s), 3.15576e+07 s)")

    """
    def __new__(cls, units, names=...): # -> <subclass of Unit and StructuredUnit> | Self@StructuredUnit:
        ...
    
    def __getnewargs__(self): # -> tuple[tuple[()], None]:
        """When de-serializing, e.g. pickle, start with a blank structure."""
        ...
    
    @property
    def field_names(self): # -> tuple[list[Unknown] | Unknown, ...]:
        """Possibly nested tuple of the field names of the parts."""
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __getitem__(self, item):
        ...
    
    def values(self):
        ...
    
    def keys(self):
        ...
    
    def items(self): # -> tuple[tuple[Unknown, Unknown], ...]:
        ...
    
    def __iter__(self): # -> Generator[Unknown, None, None]:
        ...
    
    @property
    def si(self): # -> Any | Self@StructuredUnit:
        """The `StructuredUnit` instance in SI units."""
        ...
    
    @property
    def cgs(self): # -> Any | Self@StructuredUnit:
        """The `StructuredUnit` instance in cgs units."""
        ...
    
    @property
    def physical_type(self): # -> Any | Self@StructuredUnit:
        """Physical types of all the fields."""
        ...
    
    def decompose(self, bases=...): # -> Any | Self@StructuredUnit:
        """The `StructuredUnit` composed of only irreducible units.

        Parameters
        ----------
        bases : sequence of `~astropy.units.UnitBase`, optional
            The bases to decompose into.  When not provided,
            decomposes down to any irreducible units.  When provided,
            the decomposed result will only contain the given units.
            This will raises a `UnitsError` if it's not possible
            to do so.

        Returns
        -------
        `~astropy.units.StructuredUnit`
            With the unit for each field containing only irreducible units.
        """
        ...
    
    def is_equivalent(self, other, equivalencies=...): # -> bool:
        """`True` if all fields are equivalent to the other's fields.

        Parameters
        ----------
        other : `~astropy.units.StructuredUnit`
            The structured unit to compare with, or what can initialize one.
        equivalencies : list of tuple, optional
            A list of equivalence pairs to try if the units are not
            directly convertible.  See :ref:`unit_equivalencies`.
            The list will be applied to all fields.

        Returns
        -------
        bool
        """
        ...
    
    def to(self, other, value=..., equivalencies=...): # -> NDArray[void] | Any:
        """Return values converted to the specified unit.

        Parameters
        ----------
        other : `~astropy.units.StructuredUnit`
            The unit to convert to.  If necessary, will be converted to
            a `~astropy.units.StructuredUnit` using the dtype of ``value``.
        value : array-like, optional
            Value(s) in the current unit to be converted to the
            specified unit.  If a sequence, the first element must have
            entries of the correct type to represent all elements (i.e.,
            not have, e.g., a ``float`` where other elements have ``complex``).
            If not given, assumed to have 1. in all fields.
        equivalencies : list of tuple, optional
            A list of equivalence pairs to try if the units are not
            directly convertible.  See :ref:`unit_equivalencies`.
            This list is in addition to possible global defaults set by, e.g.,
            `set_enabled_equivalencies`.
            Use `None` to turn off all equivalencies.

        Returns
        -------
        values : scalar or array
            Converted value(s).

        Raises
        ------
        UnitsError
            If units are inconsistent
        """
        ...
    
    def to_string(self, format=...): # -> LiteralString:
        """Output the unit in the given format as a string.

        Units are separated by commas.

        Parameters
        ----------
        format : `astropy.units.format.Base` instance or str
            The name of a format or a formatter object.  If not
            provided, defaults to the generic format.

        Notes
        -----
        Structured units can be written to all formats, but can be
        re-read only with 'generic'.

        """
        ...
    
    __array_ufunc__ = ...
    def __mul__(self, other): # -> _NotImplementedType | Self@StructuredUnit | Quantity:
        ...
    
    def __rmul__(self, other): # -> _NotImplementedType | Self@StructuredUnit | Quantity:
        ...
    
    def __truediv__(self, other): # -> _NotImplementedType | Self@StructuredUnit:
        ...
    
    def __rlshift__(self, m): # -> Quantity | _NotImplementedType:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


class Structure(np.void):
    """Single element structure for physical type IDs, etc.

    Behaves like a `~numpy.void` and thus mostly like a tuple which can also
    be indexed with field names, but overrides ``__eq__`` and ``__ne__`` to
    compare only the contents, not the field names.  Furthermore, this way no
    `FutureWarning` about comparisons is given.

    """
    def __eq__(self, other) -> bool:
        ...
    
    def __ne__(self, other) -> bool:
        ...
    


