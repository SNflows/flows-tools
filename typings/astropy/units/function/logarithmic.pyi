"""
This type stub file was generated by pyright.
"""

from .core import FunctionQuantity, FunctionUnitBase

__all__ = ['LogUnit', 'MagUnit', 'DexUnit', 'DecibelUnit', 'LogQuantity', 'Magnitude', 'Decibel', 'Dex', 'STmag', 'ABmag', 'M_bol', 'm_bol']
class LogUnit(FunctionUnitBase):
    """Logarithmic unit containing a physical one

    Usually, logarithmic units are instantiated via specific subclasses
    such `MagUnit`, `DecibelUnit`, and `DexUnit`.

    Parameters
    ----------
    physical_unit : `~astropy.units.Unit` or `string`
        Unit that is encapsulated within the logarithmic function unit.
        If not given, dimensionless.

    function_unit :  `~astropy.units.Unit` or `string`
        By default, the same as the logarithmic unit set by the subclass.

    """
    def from_physical(self, x): # -> float:
        """Transformation from value in physical to value in logarithmic units.
        Used in equivalency."""
        ...
    
    def to_physical(self, x): # -> float:
        """Transformation from value in logarithmic to value in physical units.
        Used in equivalency."""
        ...
    
    def __neg__(self): # -> Self@LogUnit:
        ...
    
    def __add__(self, other): # -> _NotImplementedType | Self@LogUnit:
        ...
    
    def __radd__(self, other): # -> _NotImplementedType | Self@LogUnit:
        ...
    
    def __sub__(self, other): # -> _NotImplementedType | Self@LogUnit:
        ...
    
    def __rsub__(self, other): # -> _NotImplementedType | Self@LogUnit:
        ...
    


class MagUnit(LogUnit):
    """Logarithmic physical units expressed in magnitudes

    Parameters
    ----------
    physical_unit : `~astropy.units.Unit` or `string`
        Unit that is encapsulated within the magnitude function unit.
        If not given, dimensionless.

    function_unit :  `~astropy.units.Unit` or `string`
        By default, this is ``mag``, but this allows one to use an equivalent
        unit such as ``2 mag``.
    """
    ...


class DexUnit(LogUnit):
    """Logarithmic physical units expressed in magnitudes

    Parameters
    ----------
    physical_unit : `~astropy.units.Unit` or `string`
        Unit that is encapsulated within the magnitude function unit.
        If not given, dimensionless.

    function_unit :  `~astropy.units.Unit` or `string`
        By default, this is ``dex``, but this allows one to use an equivalent
        unit such as ``0.5 dex``.
    """
    def to_string(self, format=...): # -> str:
        ...
    


class DecibelUnit(LogUnit):
    """Logarithmic physical units expressed in dB

    Parameters
    ----------
    physical_unit : `~astropy.units.Unit` or `string`
        Unit that is encapsulated within the decibel function unit.
        If not given, dimensionless.

    function_unit :  `~astropy.units.Unit` or `string`
        By default, this is ``dB``, but this allows one to use an equivalent
        unit such as ``2 dB``.
    """
    ...


class LogQuantity(FunctionQuantity):
    """A representation of a (scaled) logarithm of a number with a unit

    Parameters
    ----------
    value : number, `~astropy.units.Quantity`, `~astropy.units.function.logarithmic.LogQuantity`, or sequence of quantity-like.
        The numerical value of the logarithmic quantity. If a number or
        a `~astropy.units.Quantity` with a logarithmic unit, it will be
        converted to ``unit`` and the physical unit will be inferred from
        ``unit``.  If a `~astropy.units.Quantity` with just a physical unit,
        it will converted to the logarithmic unit, after, if necessary,
        converting it to the physical unit inferred from ``unit``.

    unit : str, `~astropy.units.UnitBase`, or `~astropy.units.function.FunctionUnitBase`, optional
        For an `~astropy.units.function.FunctionUnitBase` instance, the
        physical unit will be taken from it; for other input, it will be
        inferred from ``value``. By default, ``unit`` is set by the subclass.

    dtype : `~numpy.dtype`, optional
        The ``dtype`` of the resulting Numpy array or scalar that will
        hold the value.  If not provided, is is determined automatically
        from the input value.

    copy : bool, optional
        If `True` (default), then the value is copied.  Otherwise, a copy will
        only be made if ``__array__`` returns a copy, if value is a nested
        sequence, or if a copy is needed to satisfy an explicitly given
        ``dtype``.  (The `False` option is intended mostly for internal use,
        to speed up initialization where a copy is known to have been made.
        Use with care.)

    Examples
    --------
    Typically, use is made of an `~astropy.units.function.FunctionQuantity`
    subclass, as in::

        >>> import astropy.units as u
        >>> u.Magnitude(-2.5)
        <Magnitude -2.5 mag>
        >>> u.Magnitude(10.*u.count/u.second)
        <Magnitude -2.5 mag(ct / s)>
        >>> u.Decibel(1.*u.W, u.DecibelUnit(u.mW))  # doctest: +FLOAT_CMP
        <Decibel 30. dB(mW)>

    """
    _unit_class = LogUnit
    def __add__(self, other): # -> Self@LogQuantity | Quantity | Any:
        ...
    
    def __radd__(self, other): # -> Self@LogQuantity | Quantity | Any:
        ...
    
    def __iadd__(self, other): # -> Self@LogQuantity:
        ...
    
    def __sub__(self, other): # -> Self@LogQuantity | Quantity | Any:
        ...
    
    def __rsub__(self, other): # -> Self@LogQuantity | Quantity | Any:
        ...
    
    def __isub__(self, other): # -> Self@LogQuantity:
        ...
    
    def __mul__(self, other): # -> Self@LogQuantity | Quantity | Any:
        ...
    
    def __rmul__(self, other): # -> Self@LogQuantity | Quantity | Any:
        ...
    
    def __imul__(self, other): # -> Self@LogQuantity | LogQuantity | NDArray[bool_]:
        ...
    
    def __truediv__(self, other): # -> Self@LogQuantity | Quantity | Any:
        ...
    
    def __itruediv__(self, other): # -> Self@LogQuantity | LogQuantity | NDArray[floating[Unknown]]:
        ...
    
    def __pow__(self, other): # -> _NotImplementedType | Self@LogQuantity | Quantity | Any:
        ...
    
    def __ilshift__(self, other): # -> _NotImplementedType | Self@LogQuantity:
        ...
    
    def var(self, axis=..., dtype=..., out=..., ddof=...): # -> tuple[Unknown, ...] | list[Unknown] | Self@Quantity | Quantity | Any:
        ...
    
    def std(self, axis=..., dtype=..., out=..., ddof=...): # -> tuple[Unknown, ...] | list[Unknown] | Self@Quantity | Quantity | Any:
        ...
    
    def ptp(self, axis=..., out=...): # -> tuple[Unknown, ...] | list[Unknown] | Self@Quantity | Quantity | Any:
        ...
    
    def diff(self, n=..., axis=...): # -> tuple[Unknown, ...] | list[Unknown] | Self@Quantity | Quantity | Any:
        ...
    
    def ediff1d(self, to_end=..., to_begin=...): # -> tuple[Unknown, ...] | list[Unknown] | Self@Quantity | Quantity | Any:
        ...
    
    _supported_functions = ...


class Dex(LogQuantity):
    _unit_class = DexUnit


class Decibel(LogQuantity):
    _unit_class = DecibelUnit


class Magnitude(LogQuantity):
    _unit_class = MagUnit


STmag = ...
ABmag = ...
M_bol = ...
m_bol = ...
