"""
This type stub file was generated by pyright.
"""

import numpy as np
from astropy.utils.compat import NUMPY_LT_1_20, NUMPY_LT_1_23

"""Helpers for overriding numpy functions.

We override numpy functions in `~astropy.units.Quantity.__array_function__`.
In this module, the numpy functions are split in four groups, each of
which has an associated `set` or `dict`:

1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation
   supports Quantity; we pass on to ndarray.__array_function__.
2. FUNCTION_HELPERS (dict), if the numpy implementation is usable
   after converting quantities to arrays with suitable units,
   and possibly setting units on the result.
3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but
   requires a Quantity-specific implementation
4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.

For the FUNCTION_HELPERS `dict`, the value is a function that does the
unit conversion.  It should take the same arguments as the numpy
function would (though one can use ``*args`` and ``**kwargs``) and
return a tuple of ``args, kwargs, unit, out``, where ``args`` and
``kwargs`` will be will be passed on to the numpy implementation,
``unit`` is a possible unit of the result (`None` if it should not be
converted to Quantity), and ``out`` is a possible output Quantity passed
in, which will be filled in-place.

For the DISPATCHED_FUNCTIONS `dict`, the value is a function that
implements the numpy functionality for Quantity input. It should
return a tuple of ``result, unit, out``, where ``result`` is generally
a plain array with the result, and ``unit`` and ``out`` are as above.
If unit is `None`, result gets returned directly, so one can also
return a Quantity directly using ``quantity_result, None, None``.

"""
ARRAY_FUNCTION_ENABLED = ...
SUBCLASS_SAFE_FUNCTIONS = ...
FUNCTION_HELPERS = ...
DISPATCHED_FUNCTIONS = ...
UNSUPPORTED_FUNCTIONS = ...
TBD_FUNCTIONS = ...
IGNORED_FUNCTIONS = ...
if NUMPY_LT_1_20: ...
if NUMPY_LT_1_23: ...

class FunctionAssigner:
    def __init__(self, assignments) -> None: ...
    def __call__(self, f=..., helps=..., module=...):  # -> partial[Unknown]:
        """Add a helper to a numpy function.

        Normally used as a decorator.

        If ``helps`` is given, it should be the numpy function helped (or an
        iterable of numpy functions helped).

        If ``helps`` is not given, it is assumed the function helped is the
        numpy function with the same name as the decorated function.
        """
        ...

function_helper = FunctionAssigner(FUNCTION_HELPERS)
dispatched_function = FunctionAssigner(DISPATCHED_FUNCTIONS)

@function_helper(
    np.copy,
    np.asfarray,
    np.real_if_close,
    np.sort_complex,
    np.resize,
    np.fft.fft,
    np.fft.ifft,
    np.fft.rfft,
    np.fft.irfft,
    np.fft.fft2,
    np.fft.ifft2,
    np.fft.rfft2,
    np.fft.irfft2,
    np.fft.fftn,
    np.fft.ifftn,
    np.fft.rfftn,
    np.fft.irfftn,
    np.fft.hfft,
    np.fft.ihfft,
    np.linalg.eigvals,
    np.linalg.eigvalsh,
)
def invariant_a_helper(a, *args, **kwargs): ...
@function_helper(np.tril, np.triu)
def invariant_m_helper(m, *args, **kwargs): ...
@function_helper(np.fft.fftshift, np.fft.ifftshift)
def invariant_x_helper(x, *args, **kwargs): ...
@function_helper(np.ones_like, np.zeros_like)
def like_helper(a, *args, **kwargs): ...
@function_helper
def sinc(x): ...
@dispatched_function
def unwrap(p, discont=..., axis=...): ...
@function_helper
def argpartition(a, *args, **kwargs): ...
@function_helper
def full_like(a, fill_value, *args, **kwargs): ...
@function_helper
def putmask(a, mask, values): ...
@function_helper
def place(arr, mask, vals): ...
@function_helper
def copyto(dst, src, *args, **kwargs): ...
@function_helper
def nan_to_num(x, copy=..., nan=..., posinf=..., neginf=...): ...
@function_helper
def concatenate(arrays, axis=..., out=..., **kwargs): ...
@dispatched_function
def block(arrays): ...
@function_helper
def choose(a, choices, out=..., **kwargs): ...
@function_helper
def select(condlist, choicelist, default=...): ...
@dispatched_function
def piecewise(x, condlist, funclist, *args, **kw): ...
@function_helper
def append(arr, values, *args, **kwargs): ...
@function_helper
def insert(arr, obj, values, *args, **kwargs): ...
@function_helper
def pad(array, pad_width, mode=..., **kwargs): ...
@function_helper
def where(condition, *args): ...
@function_helper(np.quantile, np.nanquantile)
def quantile(a, q, *args, _q_unit=..., **kwargs): ...
@function_helper(np.percentile, np.nanpercentile)
def percentile(a, q, *args, **kwargs): ...
@function_helper
def count_nonzero(a, *args, **kwargs): ...
@function_helper(np.isclose, np.allclose)
def close(a, b, rtol=..., atol=..., *args, **kwargs): ...
@function_helper
def array_equal(a1, a2): ...
@function_helper
def array_equiv(a1, a2): ...
@function_helper(np.dot, np.outer)
def dot_like(a, b, out=...): ...
@function_helper(np.cross, np.inner, np.vdot, np.tensordot, np.kron, np.correlate, np.convolve)
def cross_like(a, b, *args, **kwargs): ...
@function_helper
def einsum(subscripts, *operands, out=..., **kwargs): ...
@function_helper
def bincount(x, weights=..., minlength=...): ...
@function_helper
def digitize(x, bins, *args, **kwargs): ...
@function_helper
def histogram(a, bins=..., range=..., weights=..., density=...): ...
@function_helper(np.histogram_bin_edges)
def histogram_bin_edges(a, bins=..., range=..., weights=...): ...
@function_helper
def histogram2d(x, y, bins=..., range=..., weights=..., density=...): ...
@function_helper
def histogramdd(sample, bins=..., range=..., weights=..., density=...): ...
@function_helper
def diff(a, n=..., axis=..., prepend=..., append=...): ...
@function_helper
def gradient(f, *varargs, **kwargs): ...
@function_helper
def logspace(start, stop, *args, **kwargs): ...
@function_helper
def geomspace(start, stop, *args, **kwargs): ...
@function_helper
def interp(x, xp, fp, *args, **kwargs): ...
@function_helper
def unique(ar, return_index=..., return_inverse=..., return_counts=..., axis=...): ...
@function_helper
def intersect1d(ar1, ar2, assume_unique=..., return_indices=...): ...
@function_helper((np.setxor1d, np.union1d, np.setdiff1d))
def twosetop(ar1, ar2, *args, **kwargs): ...
@function_helper((np.isin, np.in1d))
def setcheckop(ar1, ar2, *args, **kwargs): ...
@dispatched_function
def apply_over_axes(func, a, axes): ...
@dispatched_function
def array_repr(arr, *args, **kwargs): ...
@dispatched_function
def array_str(arr, *args, **kwargs): ...
@function_helper
def array2string(a, *args, **kwargs): ...
@function_helper
def diag(v, *args, **kwargs): ...
@function_helper(module=np.linalg)
def svd(a, full_matrices=..., compute_uv=..., hermitian=...): ...
@function_helper(module=np.linalg)
def matrix_rank(M, tol=..., *args, **kwargs): ...
@function_helper(np.linalg.inv, np.linalg.tensorinv)
def inv(a, *args, **kwargs): ...
@function_helper(module=np.linalg)
def pinv(a, rcond=..., *args, **kwargs): ...
@function_helper(module=np.linalg)
def det(a): ...
@function_helper(np.linalg.solve, np.linalg.tensorsolve)
def solve(a, b, *args, **kwargs): ...
@function_helper(module=np.linalg)
def lstsq(a, b, rcond=...): ...
@function_helper(module=np.linalg)
def norm(x, ord=..., *args, **kwargs): ...
@function_helper(module=np.linalg)
def matrix_power(a, n): ...
@function_helper(module=np.linalg)
def cholesky(a): ...
@function_helper(module=np.linalg)
def qr(a, mode=...): ...
@function_helper(np.linalg.eig, np.linalg.eigh)
def eig(a, *args, **kwargs): ...
@function_helper(module=np.lib.recfunctions)
def structured_to_unstructured(
    arr, *args, **kwargs
):  # -> tuple[tuple[Unknown, ...], dict[str, Unknown], Unknown, None]:
    """
    Convert a structured quantity to an unstructured one.
    This only works if all the units are compatible.

    """
    ...

@function_helper(module=np.lib.recfunctions)
def unstructured_to_structured(arr, dtype, *args, **kwargs): ...
